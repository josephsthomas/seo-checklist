[
  {
    "bug_id": "R10-C-001",
    "severity": "HIGH",
    "category": "Missing Error State",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:37",
    "description": "The onSnapshot listener in useProjects does not include an error callback. If the Firestore query fails (e.g., due to missing index, permissions error, or network disconnection), the loading state remains true indefinitely and the user sees an infinite loading spinner with no way to recover.",
    "steps": "1. Sign in as a user. 2. Navigate to a page that uses useProjects. 3. Simulate a Firestore permission error or network disconnection. 4. Observe the UI.",
    "expected": "An error state should be set, loading should be set to false, and the user should see a clear error message with a retry option.",
    "actual": "The onSnapshot listener has no error callback (second argument). On failure, loading stays true forever and the user is stuck on a loading spinner with no error message or retry affordance.",
    "impact": "Users on unreliable networks or with misconfigured permissions will be stuck on a loading screen with no way to diagnose or recover from the issue. This creates a navigation dead-end."
  },
  {
    "bug_id": "R10-C-002",
    "severity": "HIGH",
    "category": "Undo Missing",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:80",
    "description": "The deleteProject function permanently deletes a project from Firestore without any confirmation dialog or undo mechanism. A simple toast.success is shown after deletion, but there is no way to recover the deleted project or its associated data (linked items, checklist progress, time entries, etc.).",
    "steps": "1. Navigate to the Projects page. 2. Click delete on a project with substantial data. 3. Observe the project is immediately and permanently deleted.",
    "expected": "The hook should either require a confirmation step before deletion, implement a soft-delete pattern (marking as archived), or provide an undo toast with a time window to reverse the action.",
    "actual": "The project and its data are permanently deleted immediately with only a success toast shown. No confirmation, no undo, no soft-delete.",
    "impact": "Users who accidentally delete a project lose all associated work permanently. This is especially damaging for projects with linked audits, checklists, time entries, and file attachments that are also orphaned."
  },
  {
    "bug_id": "R10-C-003",
    "severity": "MEDIUM",
    "category": "Missing Error State",
    "component": "useNotifications",
    "file_line": "src/hooks/useNotifications.js:36",
    "description": "The onSnapshot listener for notifications does not include an error callback handler. If the query fails, the loading state remains true and the user never sees their notifications. Additionally, the markAsRead function (line 55) silently catches and ignores errors with an empty catch block, providing no feedback to the user.",
    "steps": "1. Log in and navigate to a page that displays notifications. 2. Simulate a Firestore permission error. 3. Observe the notification bell/panel remains in loading state indefinitely.",
    "expected": "An error handler on the onSnapshot listener should set loading to false and set an error state. The markAsRead function should at minimum log the error for debugging.",
    "actual": "The onSnapshot has no error handler, so loading stays true forever on failure. The markAsRead silently swallows errors with no logging or user feedback.",
    "impact": "Users cannot see or manage notifications when Firestore encounters errors. The silent failure in markAsRead means notifications may appear unread persistently without the user understanding why."
  },
  {
    "bug_id": "R10-C-004",
    "severity": "HIGH",
    "category": "Feedback Gap",
    "component": "useNotifications",
    "file_line": "src/hooks/useNotifications.js:60",
    "description": "The markAllAsRead function uses Firestore writeBatch without any size limit check. Firestore batches are limited to 500 operations. If a user has more than 500 unread notifications, the batch.commit() will fail, showing a generic 'Failed to mark all as read' error without explaining the issue or offering a workaround.",
    "steps": "1. Accumulate more than 500 unread notifications (e.g., in a high-activity team). 2. Click 'Mark all as read'. 3. Observe the error toast.",
    "expected": "The function should chunk the batch into groups of at most 500 operations, or use a server-side function to handle the bulk update. Clear feedback should be given during the process for large batches.",
    "actual": "All unread notifications are added to a single batch which will fail if count exceeds 500. The error message is generic and does not help the user.",
    "impact": "Power users and team leads with many notifications cannot mark them all as read, leading to a permanently cluttered notification panel and user frustration."
  },
  {
    "bug_id": "R10-C-005",
    "severity": "MEDIUM",
    "category": "Flow Break",
    "component": "useUnsavedChanges",
    "file_line": "src/hooks/useUnsavedChanges.js:14",
    "description": "The useUnsavedChanges hook only handles browser beforeunload events (page refresh/close) but provides no mechanism for intercepting in-app navigation via React Router. The JSDoc comment at line 9 says 'Can be used with React Router for navigation warnings' but the implementation does not include any React Router navigation blocking (e.g., useBlocker or usePrompt). This means users can navigate away within the SPA and lose unsaved changes without any warning.",
    "steps": "1. Open a form that uses useUnsavedChanges. 2. Make changes to the form (isDirty becomes true). 3. Click a navigation link to another page within the app. 4. Observe no warning is shown and changes are lost.",
    "expected": "In-app navigation should be blocked when isDirty is true, showing a confirmation dialog before allowing the user to leave. The hook should integrate with React Router's navigation blocking API.",
    "actual": "Only browser beforeunload is handled. In-app React Router navigation silently discards unsaved changes without warning.",
    "impact": "Users who click navigation links or use the browser back button within the SPA will lose unsaved form data without warning, leading to frustration and rework."
  },
  {
    "bug_id": "R10-C-006",
    "severity": "MEDIUM",
    "category": "Form UX Issue",
    "component": "useFormWithUnsavedChanges",
    "file_line": "src/hooks/useUnsavedChanges.js:58",
    "description": "The dirty state detection in useFormWithUnsavedChanges uses JSON.stringify comparison (line 58) to detect changes. This is unreliable for several edge cases: (1) Object property order differences will cause false positives, (2) Date objects serialize differently than Firestore Timestamps, (3) undefined values are stripped during stringify causing false negatives, and (4) it runs on every render via useEffect, which is inefficient for large forms.",
    "steps": "1. Use the form hook with initial values containing Date objects or nested objects. 2. Set the same values back in a different property order. 3. Observe the isDirty flag is incorrectly true even though values are semantically identical.",
    "expected": "The dirty detection should use a deep equality comparison that handles property ordering, undefined values, and special types correctly. Consider using a library like lodash.isEqual or a more robust comparison.",
    "actual": "JSON.stringify comparison produces false positives/negatives for objects with different property ordering, Date objects, undefined values, and other edge cases.",
    "impact": "Users may see unsaved changes warnings when they have not actually made changes (false positives), or may not be warned when they have (false negatives). Both cases erode user trust in the system."
  },
  {
    "bug_id": "R10-C-007",
    "severity": "HIGH",
    "category": "Undo Missing",
    "component": "useFileAttachments",
    "file_line": "src/hooks/useFileAttachments.js:171",
    "description": "The deleteFile function permanently deletes both the file from Firebase Storage and its metadata from Firestore without any confirmation step or undo mechanism. Once deleted, the file cannot be recovered. There is no soft-delete, no confirmation dialog, and no undo toast with a recovery window.",
    "steps": "1. Upload a file attachment to a checklist item. 2. Click delete on the attachment. 3. Observe the file is immediately and permanently deleted from both Storage and Firestore.",
    "expected": "File deletion should include a confirmation dialog ('Are you sure?') before proceeding, or provide an undo toast with a 5-10 second window to cancel. Alternatively, implement a soft-delete with a trash/recycle bin concept.",
    "actual": "The file is permanently deleted from both Firebase Storage and Firestore immediately with only a success toast. No confirmation, no undo capability.",
    "impact": "Users who accidentally click delete lose their file attachments permanently. This is especially impactful for important documents like PDFs and spreadsheets that may not be easily recreated."
  },
  {
    "bug_id": "R10-C-008",
    "severity": "MEDIUM",
    "category": "Missing Error State",
    "component": "useExportHistory",
    "file_line": "src/hooks/useExportHistory.js:87",
    "description": "The useExportHistory hook's onSnapshot listener does not include an error callback. If the Firestore query fails, loading remains true indefinitely. Additionally, the logExport function (line 100) silently returns null on error with only a console.error, providing no user feedback that the export was not logged. The deleteExport function (line 117) also silently fails.",
    "steps": "1. Navigate to the export history page. 2. Trigger a Firestore error (e.g., network disconnect). 3. Observe loading remains true forever with no error state shown.",
    "expected": "The onSnapshot should have an error callback that sets loading to false and exposes an error state. The logExport and deleteExport functions should provide user-visible feedback on failure.",
    "actual": "No error callback on onSnapshot (loading stuck on true). logExport silently returns null. deleteExport silently fails with only console.error logging.",
    "impact": "Users cannot view or manage their export history during network issues. Failed export logging means users lose track of what they exported, potentially leading to duplicate exports."
  },
  {
    "bug_id": "R10-C-009",
    "severity": "MEDIUM",
    "category": "Feedback Gap",
    "component": "useReadabilitySettings",
    "file_line": "src/hooks/useReadabilitySettings.js:58",
    "description": "The updateSettings function applies the optimistic update to local state immediately (line 61) but does not revert the state if the Firestore write fails (lines 70-73). The error is only logged to console.error and stored in an error state variable, but the UI shows the new settings values even though they were not actually persisted. There is no toast or user-visible notification of the save failure.",
    "steps": "1. Go to readability settings page. 2. Change a setting (e.g., disable an LLM). 3. Simulate a Firestore write failure. 4. Observe the UI shows the new setting value, but it was not saved.",
    "expected": "On Firestore write failure, the settings should be reverted to their previous values, and the user should see a clear error message (e.g., toast.error) indicating the settings were not saved.",
    "actual": "The optimistic update persists in the UI even when the Firestore save fails. The user believes their settings were saved, but on next page load the old settings will reappear, causing confusion.",
    "impact": "Users think they changed their settings when in fact the change was not saved. This leads to unexpected behavior on subsequent analyses and erodes trust in the settings system."
  },
  {
    "bug_id": "R10-C-010",
    "severity": "MEDIUM",
    "category": "Undo Missing",
    "component": "useSchemaLibrary",
    "file_line": "src/hooks/useSchemaLibrary.js:108",
    "description": "The deleteSchema function permanently deletes a schema from the library without any confirmation or undo mechanism. Schemas that users have carefully built, tagged, and used multiple times can be accidentally destroyed with a single click. The hook tracks usageCount, meaning heavily-used schemas could be accidentally deleted.",
    "steps": "1. Save a schema to the library. 2. Use it multiple times (usageCount > 0). 3. Click delete. 4. Observe the schema is permanently deleted with only a toast confirmation.",
    "expected": "Deletion of schemas with usageCount > 0 should require explicit confirmation. All schema deletions should have an undo toast with a recovery window, or implement a soft-delete/archive pattern.",
    "actual": "The schema is permanently deleted immediately regardless of how many times it has been used. No confirmation dialog, no undo capability.",
    "impact": "Users who accidentally delete frequently-used schemas lose valuable work and must recreate them from scratch. This is particularly impactful for shared/public schemas."
  },
  {
    "bug_id": "R10-C-011",
    "severity": "MEDIUM",
    "category": "Undo Missing",
    "component": "useTimeTracking",
    "file_line": "src/hooks/useTimeTracking.js:166",
    "description": "The deleteEntry function permanently deletes time tracking entries without confirmation or undo. Time entries represent work records that may be needed for billing, reporting, or compliance. Additionally, there is no validation to prevent deleting another user's time entries - the function only checks for the entry ID without verifying ownership.",
    "steps": "1. Log several hours of work on a checklist item. 2. Click delete on a time entry. 3. Observe the entry is permanently deleted. 4. Attempt to recover the deleted time - no option exists.",
    "expected": "Time entry deletion should require confirmation and provide an undo option. The function should also verify that the current user owns the time entry before allowing deletion.",
    "actual": "Time entries are permanently deleted immediately without confirmation or undo. No ownership check is performed, so any user could potentially delete another user's time entries.",
    "impact": "Accidental deletion of time entries leads to inaccurate project time tracking, billing discrepancies, and loss of work records needed for compliance or reporting purposes."
  },
  {
    "bug_id": "R10-C-012",
    "severity": "HIGH",
    "category": "Missing Empty State",
    "component": "usePendingExports",
    "file_line": "src/hooks/useExportHistory.js:131",
    "description": "The usePendingExports hook is a stub implementation that always returns empty arrays for all export categories. The pending state is initialized with empty arrays (line 132-139) and never populated - the useEffect simply sets loading to false. This means the pending exports feature shows no data regardless of actual pending items, providing a misleading empty state.",
    "steps": "1. Run several audits, accessibility checks, and image alt text analyses. 2. Navigate to a page that uses usePendingExports. 3. Observe that pending exports always show as empty regardless of actual data.",
    "expected": "The hook should actually query each relevant Firestore collection to determine which items have not yet been exported, or clearly indicate that this feature is not yet implemented with an appropriate UI message.",
    "actual": "The hook is a stub that always returns empty arrays. The comment says 'This would normally fetch from each collection' but no actual queries are implemented. Users see an empty state that misrepresents reality.",
    "impact": "Users cannot discover which items need to be exported, making the export workflow incomplete. The feature appears broken or misleading since data exists but the pending list is always empty."
  },
  {
    "bug_id": "R10-C-013",
    "severity": "MEDIUM",
    "category": "Feedback Gap",
    "component": "useFavoritesAndRecents",
    "file_line": "src/hooks/useFavoritesAndRecents.js:50",
    "description": "The saveData function (which persists favorites and recents to Firestore) silently fails with only a console.error. The addToFavorites, removeFromFavorites, addToRecents, and clearRecents functions all optimistically update local state before calling saveData, but if saveData fails, the local state is not reverted and no feedback is given to the user. On page refresh, the user will see their favorites/recents reverted to the last successfully saved state.",
    "steps": "1. Sign in and navigate to a page using favorites. 2. Toggle a favorite while offline or with Firestore errors. 3. Observe the favorite appears toggled in the UI. 4. Refresh the page and observe the favorite has reverted.",
    "expected": "When saveData fails, the optimistic update should be reverted and the user should see a toast notification that the change could not be saved, with the option to retry.",
    "actual": "All CRUD operations optimistically update local state and silently swallow saveData errors. The UI shows a state that is not actually persisted, causing confusion on page reload.",
    "impact": "Users believe they have favorited or recently accessed items when the changes were not actually saved. This leads to confusion and loss of trust when favorites disappear after page reload."
  },
  {
    "bug_id": "R10-C-014",
    "severity": "LOW",
    "category": "Edge Case",
    "component": "useReadabilityHistory",
    "file_line": "src/hooks/useReadabilityHistory.js:128",
    "description": "The client-side URL text search and date range filters in useReadabilityHistory are applied after Firestore pagination. This means if Firestore returns a full page of 20 results but client-side filters remove most of them, the user sees fewer results than expected and the 'Load More' button may still be present. In extreme cases, a user could see 0 results with a 'Load More' button visible, which is confusing.",
    "steps": "1. Have 20+ analyses in history. 2. Apply a search URL filter that matches only a few results. 3. Observe the first page may show 0-2 results with a 'Load More' button. 4. Click 'Load More' multiple times and observe inconsistent page sizes.",
    "expected": "Either the filtering should be done server-side in the Firestore query, or the client should automatically load additional pages until the minimum display count is met, or the empty/sparse result set should show an appropriate message.",
    "actual": "Client-side filtering after pagination causes inconsistent page sizes. Users may see empty pages with a 'Load More' button, or very few results per page despite more data existing.",
    "impact": "Users may believe they have no matching analyses when results actually exist on subsequent pages. The inconsistent pagination behavior undermines the user's ability to browse their history effectively."
  },
  {
    "bug_id": "R10-C-015",
    "severity": "MEDIUM",
    "category": "Feedback Gap",
    "component": "useDueDates",
    "file_line": "src/hooks/useDueDates.js:112",
    "description": "The markComplete function silently succeeds or fails without any user feedback. Unlike addDueDate, updateDueDate, and deleteDueDate which all show toast messages, markComplete has no toast notification on success or failure. Users click to mark a due date complete and get no confirmation that the action was recorded.",
    "steps": "1. Create a due date entry. 2. Mark it as complete. 3. Observe no toast notification appears. 4. If the Firestore update fails, observe no error feedback either.",
    "expected": "A success toast should confirm 'Due date marked as complete' and an error toast should appear if the operation fails, consistent with the other functions in this hook.",
    "actual": "No feedback is provided on success or failure. The markComplete function has only a console.error in the catch block.",
    "impact": "Users have no confirmation that their due date was marked complete, and no visibility into failures. This inconsistency with other actions in the same hook creates uncertainty about whether the action was recorded."
  },
  {
    "bug_id": "R10-C-016",
    "severity": "MEDIUM",
    "category": "Missing Error State",
    "component": "useSchemaLibrary",
    "file_line": "src/hooks/useSchemaLibrary.js:50",
    "description": "The onSnapshot error handler for useSchemaLibrary (line 50-53) catches errors and sets loading to false, but does not expose the error to the consuming component. Unlike useReportBuilder which sets an error state variable, useSchemaLibrary only logs to console.error. The returned object has no error property, so the UI cannot display an error message or retry option.",
    "steps": "1. Navigate to the schema library page. 2. Trigger a Firestore query error (e.g., missing index). 3. Observe loading completes but the page shows empty results with no error message.",
    "expected": "The hook should expose an error state that allows the consuming component to show an appropriate error message and retry button.",
    "actual": "The error is only logged to console.error. The hook returns no error state, so the consuming component shows an empty list instead of an error state, making it indistinguishable from a user with no schemas.",
    "impact": "Users see an empty schema library instead of an error message when Firestore queries fail. They may waste time trying to create schemas without realizing there is a backend connectivity problem."
  },
  {
    "bug_id": "R10-C-017",
    "severity": "LOW",
    "category": "Edge Case",
    "component": "useSchemaLibrary",
    "file_line": "src/hooks/useSchemaLibrary.js:122",
    "description": "The incrementUsage function performs a non-atomic read-then-write update on the usageCount field. It reads the current count from the local schemas state (line 123) and then writes the incremented value (line 127). If two users or sessions call incrementUsage simultaneously, one increment could be lost due to the race condition. The function also has no error handling - any Firestore write failure is uncaught.",
    "steps": "1. Open the same schema in two browser tabs. 2. Use the schema in both tabs simultaneously. 3. Observe that usageCount may only increment by 1 instead of 2.",
    "expected": "The increment should use Firestore's increment() field value for atomic updates, and the function should include error handling.",
    "actual": "The function performs a non-atomic read-write with the local state value and has no error handling. Race conditions cause lost increments and unhandled promise rejections.",
    "impact": "Usage counts become inaccurate over time, making it difficult to assess which schemas are most popular. Unhandled errors could cause silent failures."
  }
]
