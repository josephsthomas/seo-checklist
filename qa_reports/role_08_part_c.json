[
  {
    "bug_id": "R08-C-001",
    "severity": "CRITICAL",
    "category": "Permission Issue",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:80",
    "description": "The deleteProject function performs no authorization check before deleting a project document from Firestore. Any authenticated user who obtains a projectId can call deleteProject and permanently remove it, regardless of whether they are the owner or have the canDeleteProjects permission. The roles.js file defines canDeleteProjects as true only for ADMIN, yet this permission is never checked.",
    "steps": "1. Log in as a user with the 'content_writer' role (canDeleteProjects: false). 2. Obtain or guess a projectId belonging to another user. 3. Call deleteProject(projectId) from the hook. 4. Observe the project is permanently deleted without any ownership or permission validation.",
    "expected": "deleteProject should verify that the calling user has the canDeleteProjects permission (via hasPermission from roles.js) AND is the owner of the project, or is an admin. Unauthorized delete attempts should be rejected with an appropriate error.",
    "actual": "deleteProject immediately calls deleteDoc on the provided projectId with no ownership or permission check. Any authenticated user can delete any project.",
    "impact": "Critical data loss risk. Any authenticated user can delete projects belonging to other users, destroying all associated project data. This undermines the entire role-based permission model defined in roles.js."
  },
  {
    "bug_id": "R08-C-002",
    "severity": "CRITICAL",
    "category": "Data Integrity",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:80",
    "description": "When a project is deleted, there is no cascade cleanup of related data. The system stores comments (useComments), file attachments (useFileAttachments), time entries (useTimeTracking), project links (useProjectLinkedItems), and due dates (useDueDates) that all reference the projectId. Deleting a project leaves all of these child records orphaned in Firestore, creating data integrity issues and potential storage waste.",
    "steps": "1. Create a project and add comments, file attachments, time entries, linked items, and due dates to it. 2. Delete the project using deleteProject. 3. Query the 'comments', 'attachments', 'time_entries', 'projectLinks', and 'due_dates' collections for the deleted projectId. 4. Observe all child records still exist as orphans.",
    "expected": "Deleting a project should cascade delete or archive all associated child records (comments, attachments, time entries, project links, due dates) or at minimum use a soft-delete pattern that marks the project as deleted while preserving referential integrity.",
    "actual": "Only the project document itself is deleted. All associated child records remain in Firestore as orphans with references to a non-existent project.",
    "impact": "Orphaned data accumulates over time, increasing storage costs and causing confusion when orphaned records appear in queries. File attachments in Firebase Storage associated with deleted projects remain, consuming storage with no way to clean them up."
  },
  {
    "bug_id": "R08-C-003",
    "severity": "HIGH",
    "category": "Permission Issue",
    "component": "useComments",
    "file_line": "src/hooks/useComments.js:94",
    "description": "The deleteComment and updateComment functions do not verify that the calling user is the author of the comment. Any authenticated user who can access a project can delete or modify any other user's comments. Additionally, the isInternal flag on comments (which controls visibility for internal-only comments) has no permission enforcement -- the CLIENT role (which has canViewInternal: false) could potentially see or modify internal comments if they have access to the itemId.",
    "steps": "1. User A adds a comment on a checklist item. 2. User B (different user, same project) calls deleteComment(commentId) with User A's comment ID. 3. Observe the comment is deleted without any ownership verification. 4. Alternatively, User B calls updateComment to modify User A's comment text.",
    "expected": "deleteComment and updateComment should verify the calling user is the comment author (or an admin). Internal comments should only be visible to users with canViewInternal permission.",
    "actual": "Both deleteComment and updateComment accept any commentId and execute the operation without ownership checks. Internal comments have no access control enforcement.",
    "impact": "Users can tamper with or delete other users' comments, destroying audit trail evidence and collaboration history. Internal comments may be visible to client-role users."
  },
  {
    "bug_id": "R08-C-004",
    "severity": "HIGH",
    "category": "Audit Trail",
    "component": "useComments",
    "file_line": "src/hooks/useComments.js:80",
    "description": "The updateComment function updates the comment text and sets updatedAt, but does not append the previous version to the editHistory array that is initialized as an empty array on comment creation (line 64). The editHistory field exists in the data model but is never populated, making it impossible to track what a comment originally said or who changed it.",
    "steps": "1. Add a comment to a checklist item. Note the editHistory is initialized as []. 2. Edit the comment using updateComment. 3. Check the comment document in Firestore. 4. Observe that editHistory is still an empty array -- the previous text was not preserved.",
    "expected": "When a comment is updated, the previous text, the editor's userId, and a timestamp should be appended to the editHistory array, preserving a complete audit trail of all comment revisions.",
    "actual": "The editHistory array is created but never written to during updates. The updateDoc call at line 83 only sets 'text' and 'updatedAt', ignoring editHistory entirely.",
    "impact": "No audit trail for comment edits. In regulated environments or contentious projects, the inability to see what a comment originally said undermines accountability and compliance requirements."
  },
  {
    "bug_id": "R08-C-005",
    "severity": "HIGH",
    "category": "Permission Issue",
    "component": "useTimeTracking",
    "file_line": "src/hooks/useTimeTracking.js:166",
    "description": "The deleteEntry function for time tracking performs no ownership verification. Any user who knows a time entry ID can delete any other user's time entry. The hook loads all time entries for a project (not filtered by user), so all entries are visible to all project participants, but the delete operation should be restricted to the entry owner or an admin.",
    "steps": "1. User A starts and stops a timer, creating a time entry. 2. User B on the same project calls deleteEntry(entryId) with User A's entry ID. 3. Observe the time entry is deleted without any ownership check.",
    "expected": "deleteEntry should verify the calling user is the entry owner (entry.userId === currentUser.uid) or has admin privileges before allowing deletion.",
    "actual": "deleteEntry directly calls deleteDoc without any ownership verification. Any authenticated user can delete any time entry they have the ID for.",
    "impact": "Time tracking data can be tampered with by any project member, undermining project management accuracy and potentially allowing billing fraud."
  },
  {
    "bug_id": "R08-C-006",
    "severity": "HIGH",
    "category": "Permission Issue",
    "component": "useFileAttachments",
    "file_line": "src/hooks/useFileAttachments.js:171",
    "description": "The deleteFile function does not verify that the current user is the uploader of the file (uploadedBy field). Any user with access to the project and item can delete file attachments uploaded by other users. The attachment metadata includes 'uploadedBy' (line 142) but this field is never checked during deletion.",
    "steps": "1. User A uploads a file attachment to a checklist item. 2. User B, who also has access to the project, calls deleteFile(attachmentId). 3. Observe the file is deleted from both Firebase Storage and Firestore without ownership verification.",
    "expected": "deleteFile should check that currentUser.uid matches attachment.uploadedBy, or that the user has admin/project-manager privileges, before allowing deletion.",
    "actual": "deleteFile finds the attachment in the local state array and immediately deletes it from both Storage and Firestore without any authorization check.",
    "impact": "Users can delete other team members' file uploads, potentially destroying evidence, deliverables, or compliance documentation."
  },
  {
    "bug_id": "R08-C-007",
    "severity": "HIGH",
    "category": "Scope Gap",
    "component": "roles",
    "file_line": "src/utils/roles.js:95",
    "description": "The permission system defined in roles.js is comprehensive but almost entirely unenforced in the CRUD hooks. The ROLE_PERMISSIONS matrix defines granular permissions (canCreateProjects, canDeleteProjects, canAssignTasks, canEditAllItems, canViewAllProjects, canManageTeam, etc.), and the hasPermission() utility function exists, but none of the data mutation hooks (useProjects, useComments, useTimeTracking, useFileAttachments, useSchemaLibrary, useReportBuilder, useDueDates, useProjectLinkedItems) import or call hasPermission() before performing create/update/delete operations.",
    "steps": "1. Search the entire codebase (hooks directory) for imports of 'hasPermission' or 'ROLE_PERMISSIONS' from roles.js. 2. Observe that none of the CRUD hooks reference the permission system. 3. Log in as a CLIENT role user (canCreateProjects: false, canExport: false). 4. Attempt to create a project via createProject -- observe it succeeds despite the permission matrix saying otherwise.",
    "expected": "All CRUD hooks should enforce the permission matrix defined in roles.js. For example, createProject should check hasPermission(userRole, 'canCreateProjects') before allowing the operation.",
    "actual": "The permission matrix in roles.js is purely decorative. No CRUD hook enforces these permissions, making the entire role-based access control system non-functional at the data layer.",
    "impact": "The defined role hierarchy (Admin > PM > SEO Specialist > Developer > Content Writer > Client) is not enforced. Clients can create projects, delete data, and perform actions explicitly forbidden by their role. This is a fundamental security gap."
  },
  {
    "bug_id": "R08-C-008",
    "severity": "HIGH",
    "category": "Workflow Gap",
    "component": "useNotifications",
    "file_line": "src/hooks/useNotifications.js:77",
    "description": "The useNotifications hook only provides markAsRead and markAllAsRead operations but has no capability to delete notifications. Over time, users will accumulate an unbounded number of notification documents in Firestore. The query at line 30 loads ALL notifications for the user with no limit, which will cause performance degradation as the notification count grows. There is also no mechanism for notification expiry or cleanup.",
    "steps": "1. Over several months of use, accumulate hundreds of notifications. 2. Observe the notification query loads all of them on every page load with no pagination or limit. 3. Attempt to delete old notifications -- no delete function is available. 4. Over time, notice the notification dropdown becoming sluggish.",
    "expected": "The notification system should include: (a) a deleteNotification function, (b) a clearAll or deleteOld function, (c) a query limit or pagination to prevent loading unbounded data, and (d) an automatic cleanup mechanism for old read notifications.",
    "actual": "Notifications can only be created and marked as read. They cannot be deleted. The query has no limit clause, loading all historical notifications on every mount.",
    "impact": "Progressive performance degradation as notification count grows. Users cannot manage their notification inbox, leading to poor UX. Firestore read costs increase linearly with notification volume."
  },
  {
    "bug_id": "R08-C-009",
    "severity": "MEDIUM",
    "category": "Data Integrity",
    "component": "auditStorageService",
    "file_line": "src/lib/audit/auditStorageService.js:77",
    "description": "The saveAudit function silently truncates audit data: issues are limited to the first 500 (line 77) and urlData is sampled to the first 100 (line 81). This truncation happens without notifying the user. For large sites with thousands of issues or URLs, the saved audit will be incomplete, and there is no indicator in the stored document that data was truncated. Users who later retrieve the audit will see partial data and may draw incorrect conclusions.",
    "steps": "1. Run an audit on a large site that produces 1,000+ issues and 500+ URLs. 2. Save the audit using saveAudit. 3. Later retrieve the audit using getAudit. 4. Observe that only the first 500 issues and 100 URL data entries are present. 5. Note there is no field in the document indicating the data was truncated.",
    "expected": "The saved audit document should include a field like 'isTruncated: true' and 'originalIssueCount' to indicate data loss. Ideally, overflow data should be stored in subcollections or Firebase Storage to preserve the complete audit.",
    "actual": "Data is silently truncated. The 'issueCount' field stores the original count (line 75), but the actual issues array is capped at 500 with no truncation indicator.",
    "impact": "Users may make business decisions based on incomplete audit data without knowing the data is partial. Critical issues beyond the 500-item cutoff will be invisible."
  },
  {
    "bug_id": "R08-C-010",
    "severity": "MEDIUM",
    "category": "Lifecycle Issue",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:49",
    "description": "The project lifecycle has no status management. The createProject function stores whatever is in projectData without enforcing an initial status. There is no defined project status workflow (e.g., draft -> active -> completed -> archived), no status transitions, no validation that status changes are valid, and no mechanism to archive completed projects. The TASK_STATUS enum exists in roles.js (NOT_STARTED, IN_PROGRESS, IN_REVIEW, COMPLETED) but there is no equivalent PROJECT_STATUS, and the updateProject function accepts any arbitrary updates without validation.",
    "steps": "1. Create a project -- observe no default status is set. 2. Update the project status to 'completed'. 3. Update it again to 'not_started' -- observe no validation prevents backward transitions. 4. Try to archive a project -- no archive capability exists.",
    "expected": "Projects should have a defined lifecycle with valid status states and enforced transitions. There should be project archive functionality, and completed projects should have restricted editing.",
    "actual": "No project status management exists. The updateProject function accepts any arbitrary field changes without validation. There is no project archival or lifecycle management.",
    "impact": "No way to formally close or archive projects. Projects remain active indefinitely in the user's project list. No workflow governance for project lifecycle transitions."
  },
  {
    "bug_id": "R08-C-011",
    "severity": "MEDIUM",
    "category": "Audit Trail",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:66",
    "description": "Project create, update, and delete operations generate no audit log entries. There is an 'activity_log' collection referenced in useUserProfile.js (line 148), but no project CRUD operation writes to it. Critical actions like project deletion leave no trace of who deleted what and when. The updatedAt timestamp is maintained, but there is no record of what was changed or by whom.",
    "steps": "1. Create a project. 2. Update the project name and description. 3. Delete the project. 4. Query the 'activity_log' collection for any entries related to this project. 5. Observe no audit log entries exist for any of these operations.",
    "expected": "All project CRUD operations should create entries in the activity_log collection capturing: the action (create/update/delete), the userId, the projectId, a timestamp, and for updates, the fields that changed.",
    "actual": "No audit logging occurs for any project CRUD operation. The activity_log collection exists but is not populated by project hooks.",
    "impact": "No accountability for project changes. If a project is accidentally deleted or maliciously modified, there is no audit trail to investigate what happened or who was responsible."
  },
  {
    "bug_id": "R08-C-012",
    "severity": "MEDIUM",
    "category": "Scope Gap",
    "component": "useSchemaLibrary",
    "file_line": "src/hooks/useSchemaLibrary.js:108",
    "description": "The deleteSchema function does not verify ownership before deletion. Any authenticated user who knows a schema ID can delete another user's schema from the library. Additionally, schemas can be marked as isPublic (line 75) to be shared, but there is no mechanism for other users to actually discover or query public schemas. The isPublic flag is stored but never used in any query, rendering the sharing feature non-functional.",
    "steps": "1. User A saves a schema with isPublic: true. 2. User B attempts to find public schemas -- no query or UI exists for this. 3. User B, if they know User A's schemaId, can call deleteSchema(schemaId) and delete User A's schema. 4. Observe no ownership check prevents this.",
    "expected": "deleteSchema should verify the calling user owns the schema. Public schemas should be discoverable through a separate query that filters on isPublic: true across all users.",
    "actual": "deleteSchema has no ownership check. The isPublic field exists but public schema discovery is not implemented -- the query at line 34 always filters by userId, so only the user's own schemas are ever visible.",
    "impact": "Schema sharing feature is incomplete (isPublic flag is stored but non-functional). Any user can delete any schema they have the ID for."
  },
  {
    "bug_id": "R08-C-013",
    "severity": "MEDIUM",
    "category": "Workflow Gap",
    "component": "retentionPolicy",
    "file_line": "src/lib/retentionPolicy.js:38",
    "description": "The retention policy module defines retention periods and provides utility functions (calculateRetentionCutoff, isWithinRetention), but there is no actual enforcement mechanism. No scheduled job, cleanup function, or data pruning logic references these utilities. The retention policy is purely configuration with no implementation. Data that exceeds the configured retention period is never automatically purged.",
    "steps": "1. Configure a retention period of 30 days. 2. Create audit data and wait 31+ days. 3. Observe the data is still present and accessible. 4. Search the codebase for any code that calls calculateRetentionCutoff or isWithinRetention to actually delete expired data. 5. Find no enforcement implementation.",
    "expected": "A background process or triggered function should periodically check data against the retention policy and purge or archive data that exceeds the configured retention period.",
    "actual": "The retention policy is purely declarative. No code enforces it. The utility functions exist but are never called in a data cleanup context.",
    "impact": "Compliance risk: organizations expecting data to be automatically purged per retention policy will find data persists indefinitely. May violate GDPR, HIPAA, or other regulatory requirements around data retention."
  },
  {
    "bug_id": "R08-C-014",
    "severity": "MEDIUM",
    "category": "Data Integrity",
    "component": "storageHelpers",
    "file_line": "src/utils/storageHelpers.js:186",
    "description": "The storageHelpers module maintains a parallel localStorage-based data system (time entries, project metadata, filter presets, activity log) that is completely disconnected from the Firestore-based system used by the hooks. For example, addTimeEntry in storageHelpers writes to localStorage, while useTimeTracking writes to Firestore. There is no synchronization between these two data stores, meaning data written via one mechanism is invisible to the other. This creates a split-brain data integrity problem.",
    "steps": "1. Use the useTimeTracking hook to log a time entry (writes to Firestore). 2. Call getTimeEntries from storageHelpers (reads from localStorage). 3. Observe the Firestore time entry does not appear in the localStorage results. 4. Similarly, call addTimeEntry from storageHelpers. 5. Observe the localStorage entry does not appear in the useTimeTracking hook's Firestore-sourced data.",
    "expected": "There should be a single source of truth for each data type. Either localStorage or Firestore should be used, not both. If both are needed (e.g., offline support), there should be a synchronization mechanism.",
    "actual": "Two independent, unsynchronized data stores exist for overlapping data (time entries, project metadata). Data written to one is invisible to the other.",
    "impact": "Users may see inconsistent data depending on which component they interact with. Time entries, project metadata, and activity data can be lost or duplicated across the two unsynchronized stores."
  },
  {
    "bug_id": "R08-C-015",
    "severity": "MEDIUM",
    "category": "Workflow Gap",
    "component": "useReadabilityAnalysis",
    "file_line": "src/hooks/useReadabilityAnalysis.js:173",
    "description": "The enforceStorageLimit function auto-deletes the oldest analyses when the storage limit is exceeded, but this happens silently with no user notification or confirmation. Users lose historical analysis data without being warned beforehand. There is no warning when approaching the limit, no option to choose which analyses to delete, and no archive mechanism to preserve data in a cheaper storage tier before deletion.",
    "steps": "1. As an 'seo_specialist' role user (limit: 100 analyses), create 100 readability analyses. 2. Run a 101st analysis. 3. Observe that the oldest analysis is silently deleted to make room. 4. Note there was no warning that the limit was being approached, and no confirmation before the deletion occurred.",
    "expected": "Users should receive a warning when approaching their storage limit (e.g., at 80% and 90%). When the limit is reached, users should be given the option to delete specific analyses or upgrade their storage tier. Auto-deletion should be a last resort with explicit notification.",
    "actual": "Oldest analyses are silently auto-deleted when the limit is reached. No warnings are issued when approaching the limit. Users discover data loss only when they notice missing historical analyses.",
    "impact": "Users lose historical analysis data without consent. This is particularly problematic for trend tracking (BRD US-2.5.2), as deleted analyses break the score progression history."
  },
  {
    "bug_id": "R08-C-016",
    "severity": "LOW",
    "category": "Audit Trail",
    "component": "auditStorageService",
    "file_line": "src/lib/audit/auditStorageService.js:296",
    "description": "The shared audit view count increment in getSharedAudit (line 297-298) uses a non-atomic read-then-write pattern. The current viewCount is read from the document, incremented in JavaScript, and written back. Under concurrent access, multiple viewers could read the same viewCount value simultaneously and all write the same incremented value, resulting in lost view counts. Firestore provides the increment() server-side function specifically for this use case.",
    "steps": "1. Create a shared audit link. 2. Have 10 users access the shared link simultaneously. 3. Observe the viewCount in Firestore. 4. Note the viewCount may be less than 10 due to lost concurrent updates.",
    "expected": "Use Firestore's increment() function (from firebase/firestore) for atomic counter updates: updateDoc(shareRef, { viewCount: increment(1) }).",
    "actual": "View count uses non-atomic read-modify-write: reads shareData.viewCount, adds 1 in JavaScript, then writes back. This is subject to race conditions under concurrent access.",
    "impact": "Shared audit view counts may be inaccurate under concurrent access. While not business-critical, inaccurate analytics undermine trust in the reporting system."
  }
]
