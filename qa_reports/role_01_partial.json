[
  {
    "bug_id": "R01-001",
    "severity": "HIGH",
    "category": "Performance Bug",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:250",
    "description": "Context value object is not memoized with useMemo. Every render of AuthProvider creates a new object reference, causing all context consumers to re-render unnecessarily.",
    "steps": "1. Open React DevTools Profiler\n2. Interact with any component using useAuth()\n3. Observe all consumers re-render on every AuthProvider render",
    "expected": "Context value should be memoized with useMemo to prevent unnecessary consumer re-renders",
    "actual": "New object is created on every render, triggering re-renders in all consumers",
    "impact": "Performance degradation across entire app since useAuth() is used in nearly every component"
  },
  {
    "bug_id": "R01-002",
    "severity": "MEDIUM",
    "category": "Race Condition",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:229",
    "description": "refreshUser checks currentUser.emailVerified after reload, but currentUser is the stale React state value. After currentUser.reload(), updated data is on auth.currentUser, not the state variable.",
    "steps": "1. Register a new account\n2. Verify email externally\n3. Call refreshUser()\n4. Check if emailVerified updates in Firestore",
    "expected": "Should use auth.currentUser.emailVerified after reload to get updated status",
    "actual": "Uses stale state value currentUser.emailVerified which hasn't updated yet",
    "impact": "Email verification status in Firestore may not update correctly on refresh"
  },
  {
    "bug_id": "R01-003",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:162",
    "description": "deleteAccount uses Firestore writeBatch which has a hard limit of 500 operations. If a user has hundreds of projects, the batch will fail.",
    "steps": "1. Create a user with 500+ projects\n2. Attempt to delete account\n3. Observe batch operation failure",
    "expected": "Should chunk operations into multiple batches of max 500",
    "actual": "All deletes go into a single batch which fails if over 500 operations",
    "impact": "Users with many projects cannot delete their accounts"
  },
  {
    "bug_id": "R01-004",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:185",
    "description": "listAll in Firebase Storage only returns first page (max 1000 items). Nested subdirectories are not recursively traversed, leaving orphaned files after account deletion.",
    "steps": "1. Upload 1000+ files to storage\n2. Delete account\n3. Check storage for remaining files",
    "expected": "Should paginate with pageToken and recursively handle prefixes",
    "actual": "Only first page of files deleted; nested directories skipped",
    "impact": "Orphaned files remain in Firebase Storage after account deletion"
  },
  {
    "bug_id": "R01-005",
    "severity": "HIGH",
    "category": "Missing Error Handling",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:156",
    "description": "deleteAccount only supports re-authentication via EmailAuthProvider.credential. Google OAuth users cannot re-authenticate with a password, causing deletion to fail.",
    "steps": "1. Sign in with Google OAuth\n2. Attempt to delete account\n3. Enter any password\n4. Observe authentication failure",
    "expected": "Should detect auth provider and use appropriate re-authentication method",
    "actual": "Always uses EmailAuthProvider.credential which fails for Google-only users",
    "impact": "Google OAuth users cannot delete their accounts; potential GDPR compliance issue"
  },
  {
    "bug_id": "R01-006",
    "severity": "MEDIUM",
    "category": "Performance Bug",
    "component": "ThemeContext",
    "file_line": "src/contexts/ThemeContext.jsx:80",
    "description": "Context value object is not memoized with useMemo. A new value object is created every render, causing unnecessary re-renders in all theme context consumers.",
    "steps": "1. Toggle theme\n2. Profile with React DevTools\n3. Observe all theme consumers re-render",
    "expected": "Value should be memoized: useMemo(() => ({...}), [theme, resolvedTheme])",
    "actual": "New object created on every render",
    "impact": "Unnecessary re-renders in all components using useTheme()"
  },
  {
    "bug_id": "R01-007",
    "severity": "LOW",
    "category": "Performance Bug",
    "component": "App",
    "file_line": "src/App.jsx:136",
    "description": "useCommandPalette() hook creates keyboard event listeners even for unauthenticated users who will never see the CommandPalette component.",
    "steps": "1. Visit app without logging in\n2. Check event listeners in DevTools\n3. Observe keyboard listener from CommandPalette active",
    "expected": "Keyboard listener should only be active for authenticated users",
    "actual": "Event listeners registered for all users regardless of auth state",
    "impact": "Wasted event listeners and potential keyboard shortcut conflicts for unauthenticated users"
  },
  {
    "bug_id": "R01-008",
    "severity": "LOW",
    "category": "React Anti-Pattern",
    "component": "lazyWithRetry",
    "file_line": "src/utils/lazyWithRetry.js:32",
    "description": "Retry delay is a fixed 1000ms without exponential backoff. All three retries use the same delay, reducing effectiveness for transient network issues.",
    "steps": "1. Simulate intermittent network failure\n2. Trigger lazy component load\n3. Observe all retries at 1s intervals",
    "expected": "Should use exponential backoff (e.g., 1s, 2s, 4s)",
    "actual": "Fixed 1s delay between all retries",
    "impact": "Reduced effectiveness of retry logic during network instability"
  },
  {
    "bug_id": "R01-009",
    "severity": "HIGH",
    "category": "Hook Misuse",
    "component": "SEOChecklist",
    "file_line": "src/components/checklist/SEOChecklist.jsx:68",
    "description": "Debounce function wrapped in useCallback is an anti-pattern. When deps change, useCallback creates a new debounced function, resetting the internal timer and canceling any pending debounced call.",
    "steps": "1. Open a project checklist\n2. Change filters rapidly\n3. Navigate between projects\n4. Observe filter saves dropped",
    "expected": "Use useRef to hold the debounced function, or use a custom useDebounce hook",
    "actual": "Debounce function recreated on dependency change, losing pending calls",
    "impact": "Filter state may not persist to Firebase correctly on project switches"
  },
  {
    "bug_id": "R01-010",
    "severity": "HIGH",
    "category": "Performance Bug",
    "component": "SEOChecklist",
    "file_line": "src/components/checklist/SEOChecklist.jsx:125",
    "description": "useEffect depends on getProject from useProjects hook. Since useProjects doesn't memoize getProject with useCallback, it creates a new function reference every render, causing repeated Firestore fetches.",
    "steps": "1. Open a project checklist\n2. Monitor network tab for repeated Firestore reads\n3. Observe getProject called repeatedly",
    "expected": "getProject should be wrapped in useCallback in useProjects, or removed from deps",
    "actual": "getProject changes reference every render, causing repeated fetches",
    "impact": "Excessive Firestore reads and possible infinite loop on project load"
  },
  {
    "bug_id": "R01-011",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "AuditPage",
    "file_line": "src/components/audit/AuditPage.jsx:82",
    "description": "urlData state stores the entire parsed URL dataset in memory without pagination or virtualization. For large sites with thousands of URLs, this consumes significant memory.",
    "steps": "1. Upload Screaming Frog export with 50,000+ URLs\n2. Process the audit\n3. Monitor memory usage in DevTools",
    "expected": "Large datasets should be paginated or virtualized",
    "actual": "Entire URL dataset stored in React state",
    "impact": "Memory issues and potential browser tab crashes for large audits"
  },
  {
    "bug_id": "R01-012",
    "severity": "MEDIUM",
    "category": "Hook Misuse",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:96",
    "description": "eslint-disable hides missing dependency history.getAnalysisById. If history object changes, the effect won't re-run with updated function.",
    "steps": "1. Navigate to /app/readability/someId\n2. Log out and log in as different user\n3. Observe stale analysis data displayed",
    "expected": "history.getAnalysisById should be in dependency array or stabilized",
    "actual": "Dependency suppressed with eslint-disable; potential stale data",
    "impact": "Could show wrong user's analysis data after auth state change"
  },
  {
    "bug_id": "R01-013",
    "severity": "MEDIUM",
    "category": "Hook Misuse",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:114",
    "description": "eslint-disable hides missing dependencies (navigate, analysis) in useEffect watching analysis state changes.",
    "steps": "1. Start a readability analysis\n2. While processing, navigate away and back\n3. Analysis completes but URL may not update",
    "expected": "All required dependencies should be in the array",
    "actual": "Missing deps suppressed; potential stale closures",
    "impact": "URL may not update after analysis completion in certain navigation scenarios"
  },
  {
    "bug_id": "R01-014",
    "severity": "MEDIUM",
    "category": "Performance Bug",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:117",
    "description": "handleAnalyzeUrl, handleAnalyzeHtml, handleAnalyzePaste depend on [analysis] which is the entire hook return object. This object changes every render causing callbacks to be recreated every render.",
    "steps": "1. Open ReadabilityPage\n2. Profile with React DevTools\n3. Observe ReadabilityInputScreen re-renders on every parent render",
    "expected": "Should depend on specific stable functions like [analysis.analyzeUrl]",
    "actual": "Depends on entire analysis object which changes every render",
    "impact": "Unnecessary re-renders of child components receiving these callbacks as props"
  },
  {
    "bug_id": "R01-015",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:217",
    "description": "fetchUserProfile silently catches all errors with empty catch block. Network failures or permission errors are swallowed, leaving userProfile as null with no failure indication.",
    "steps": "1. Sign in while Firestore is unreachable\n2. Observe userProfile remains null\n3. No error message shown",
    "expected": "Should set error state or retry, not silently fail",
    "actual": "Empty catch block swallows all errors",
    "impact": "Users appear to have no profile with no error indication"
  }
]
