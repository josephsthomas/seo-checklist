[
  {
    "bug_id": "R08-B-001",
    "severity": "CRITICAL",
    "category": "Data Integrity",
    "component": "AuthContext - Account Deletion",
    "file_line": "src/contexts/AuthContext.jsx:162",
    "description": "Account deletion batch operation does not clean up all user-related collections. The deleteAccount function only deletes projects owned by the user and notification settings, but fails to delete related data such as comments, assignments, activity_log entries, feedback submissions, due dates, linked items, checklist data, favorites, and export history. This leaves orphaned data in Firestore after account deletion, violating GDPR/data privacy requirements.",
    "steps": "1. Create a user account and populate it with projects, comments, assignments, due dates, and feedback. 2. Navigate to Settings > Danger Zone. 3. Delete the account. 4. Inspect Firestore collections for residual data associated with the deleted user ID.",
    "expected": "All user-associated data across all collections (comments, assignments, activity_log, feedback, due_dates, favorites, checklist_assignments, etc.) should be deleted as part of the account deletion batch operation.",
    "actual": "Only projects (where ownerId matches), notification settings, user profile, and storage files are deleted. Comments, assignments, activity logs, feedback, due dates, linked project items, and other user-generated data remain orphaned in Firestore.",
    "impact": "Potential GDPR/privacy compliance violation. Orphaned data can accumulate indefinitely, increasing storage costs and creating data integrity issues. Users who delete their accounts expect complete data removal."
  },
  {
    "bug_id": "R08-B-002",
    "severity": "HIGH",
    "category": "Permission Issue",
    "component": "AuthContext - Role Assignment",
    "file_line": "src/contexts/AuthContext.jsx:52",
    "description": "All new users are automatically assigned the 'project_manager' role with no admin approval workflow or role verification. Both email signup (line 52) and Google OAuth signup (line 90) hardcode the role to 'project_manager'. There is no mechanism for an administrator to review, approve, or modify user roles upon registration, nor is there any role hierarchy enforcement throughout the application.",
    "steps": "1. Register a new account via email or Google OAuth. 2. Check the Firestore 'users' document for the new user. 3. Note the role is automatically set to 'project_manager'. 4. Attempt to find any admin approval or role management interface for new registrations.",
    "expected": "New user registration should follow a configurable role assignment workflow where administrators can define default roles, approve new users, or assign appropriate roles. At minimum, new users should receive a restricted 'viewer' or 'member' role until promoted.",
    "actual": "Every new user automatically receives 'project_manager' role with no admin oversight, approval process, or ability to configure default roles. This grants full project management capabilities to any user who self-registers.",
    "impact": "Any person who creates an account automatically gets elevated project management permissions. This is a significant security and governance concern for teams that need controlled access, potentially allowing unauthorized users to create/modify/delete projects and assign tasks."
  },
  {
    "bug_id": "R08-B-003",
    "severity": "HIGH",
    "category": "Workflow Gap",
    "component": "ScheduledReportsPanel",
    "file_line": "src/components/reports/ScheduledReportsPanel.jsx:148",
    "description": "The ScheduledReportsPanel stores all schedule data in local React state only. The TODO comment on line 154 ('TODO: Load scheduled reports from Firestore') confirms that scheduled reports are never persisted to any backend. This means all scheduled report configurations are lost on page refresh, browser close, or navigation away from the panel.",
    "steps": "1. Navigate to the Reports > Scheduled Reports panel. 2. Click 'New Schedule' and create a scheduled report with recipients. 3. Save the schedule. 4. Refresh the browser page. 5. Observe that the scheduled report has disappeared.",
    "expected": "Scheduled report configurations should persist across sessions. Created schedules should be saved to Firestore and reloaded when the user revisits the panel. Active schedules should actually trigger report generation at the configured intervals.",
    "actual": "Schedules are stored only in component state (useState on line 148) and the Firestore loading is marked as TODO. All schedules are lost on page refresh. Additionally, the 'Run Now' function on line 224 only simulates execution via setTimeout rather than actually generating reports.",
    "impact": "The entire scheduled reports feature is non-functional in production. Users who configure automated report delivery will find their schedules gone after any navigation event. This represents a complete feature gap for automated reporting workflows."
  },
  {
    "bug_id": "R08-B-004",
    "severity": "HIGH",
    "category": "Audit Trail",
    "component": "useComments - Comment Edit History",
    "file_line": "src/hooks/useComments.js:80",
    "description": "The updateComment function does not maintain an edit history despite the data model supporting it. When a comment is created (line 64), an 'editHistory' array is initialized as empty. However, when updateComment is called (line 80), it only updates the text and updatedAt timestamp, without appending the previous text and edit timestamp to the editHistory array. The original comment text is permanently overwritten.",
    "steps": "1. Open a project and navigate to a checklist item. 2. Add a comment. 3. Edit the comment text. 4. Attempt to view the original comment text or edit history. 5. Inspect the Firestore 'comments' document to verify editHistory is still empty.",
    "expected": "Each comment edit should append the previous version (text, userId, timestamp) to the editHistory array before updating the current text. Users should be able to view the edit history to see what was changed and when.",
    "actual": "The editHistory array remains empty forever. The updateDoc call on line 83 only sets text and updatedAt, never pushes to editHistory. Previous comment text is permanently lost on edit.",
    "impact": "Loss of audit trail for comment edits. In a collaborative project management context, the inability to track comment changes undermines accountability and creates disputes about what was communicated. The data model supports it but the implementation skips it."
  },
  {
    "bug_id": "R08-B-005",
    "severity": "HIGH",
    "category": "Permission Issue",
    "component": "useComments - Comment Deletion",
    "file_line": "src/hooks/useComments.js:94",
    "description": "The deleteComment function has no ownership or permission check. Any authenticated user can delete any comment by providing the commentId, regardless of whether they authored the comment or have admin privileges. The function directly calls deleteDoc without verifying that currentUser.uid matches the comment's userId field.",
    "steps": "1. User A adds a comment on a project checklist item. 2. User B, who has a different role or is a different team member, calls the deleteComment function with User A's comment ID. 3. The comment is permanently deleted without any authorization check.",
    "expected": "Comment deletion should verify that the requesting user is either the comment author (userId matches) or has an admin/project-owner role. Non-authorized users should receive an error message and the delete should be prevented.",
    "actual": "The deleteComment function (line 94-101) takes only commentId, performs no ownership or permission check, and directly executes deleteDoc. Any authenticated user can delete any comment in the system.",
    "impact": "Any team member can delete another user's comments, leading to loss of project communication history, potential sabotage of audit trails, and undermining of collaborative workflows. This is especially problematic in multi-team environments."
  },
  {
    "bug_id": "R08-B-006",
    "severity": "MEDIUM",
    "category": "Workflow Gap",
    "component": "useAssignments - Task Unassignment",
    "file_line": "src/hooks/useAssignments.js:150",
    "description": "The unassignTask function does not log activity or send notifications when a task is unassigned. While assignTask (line 42) properly logs activity and sends notifications to assigned users, and updateTaskStatus (line 107) logs activity, the unassignTask function (line 150) only deletes the assignment data without any audit logging or notification to the previously assigned users.",
    "steps": "1. Assign a task to a team member (notifications and activity log entries are created). 2. Unassign the same task. 3. Check the activity log for an 'unassigned_task' entry. 4. Check if the previously assigned users received a notification about being unassigned.",
    "expected": "Unassigning a task should log an activity entry (e.g., 'unassigned_task') and notify the previously assigned users that they have been removed from the task, maintaining a complete audit trail of assignment changes.",
    "actual": "The unassignTask function only updates local state, sets the Firestore field to null, and shows a toast. No activity is logged and no notifications are sent to the previously assigned users. The previously assigned userIds are not even captured before deletion for notification purposes.",
    "impact": "Incomplete audit trail for task assignment changes. Team members may not realize they've been removed from a task, causing confusion about responsibilities. Project managers lose visibility into assignment change history."
  },
  {
    "bug_id": "R08-B-007",
    "severity": "MEDIUM",
    "category": "Missing Feature",
    "component": "ReportBuilderPage - Delete Confirmation",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:522",
    "description": "The delete button for saved reports in the Report Builder sidebar has no confirmation dialog. Clicking the Trash2 icon button immediately calls deleteReport(report.id) without any confirmation prompt. This is inconsistent with other delete patterns in the application (e.g., ScheduledReportsPanel uses a confirmation modal, ReadabilityHistory uses a two-step confirmation).",
    "steps": "1. Navigate to the Report Builder page. 2. Click 'Saved' in the sidebar to view saved reports. 3. Click the trash icon on any saved report. 4. Observe that the report is deleted immediately without any confirmation.",
    "expected": "A confirmation dialog should appear before permanently deleting a saved report, consistent with the delete patterns used elsewhere in the application. The dialog should identify the report name and warn that this action cannot be undone.",
    "actual": "Clicking the delete icon (line 522) directly invokes deleteReport(report.id) with no intermediate confirmation step. The report is irreversibly deleted with a single click.",
    "impact": "Users can accidentally delete carefully built custom reports with a single misclick. Reports may contain significant configuration effort (widgets, layouts, data sources) that cannot be recovered, leading to loss of work."
  },
  {
    "bug_id": "R08-B-008",
    "severity": "MEDIUM",
    "category": "Scope Gap",
    "component": "ScheduledReportsPanel - Email Validation",
    "file_line": "src/components/reports/ScheduledReportsPanel.jsx:661",
    "description": "The scheduled report form accepts comma-separated recipient emails (line 661) but performs no email format validation. The handleSubmit function (line 645) only checks that the recipients field is not empty (line 652), then splits by comma and trims. Invalid email addresses like 'not-an-email', empty strings from double commas, or malformed addresses pass through without validation.",
    "steps": "1. Open the Scheduled Reports panel. 2. Click 'New Schedule'. 3. Navigate to Step 3 (Delivery). 4. Enter invalid email addresses like 'abc, , not@valid, @@@' in the recipients field. 5. Submit the form.",
    "expected": "Each recipient email should be validated against a standard email format regex. Invalid emails should be highlighted with error messages, preventing form submission until all recipients have valid email addresses.",
    "actual": "The form only checks that the recipients string is not blank (line 652). It splits by comma and filters empty strings, but 'abc', '@@@', and other malformed addresses are accepted as valid recipients, which would cause delivery failures.",
    "impact": "Scheduled reports with invalid recipient emails will silently fail to deliver. Users won't discover the issue until they notice missing reports, wasting scheduling effort and potentially missing critical report deadlines."
  },
  {
    "bug_id": "R08-B-009",
    "severity": "MEDIUM",
    "category": "Lifecycle Issue",
    "component": "ReadabilityWeightConfig - State Persistence",
    "file_line": "src/components/readability/ReadabilityWeightConfig.jsx:26",
    "description": "The ReadabilityWeightConfig component stores custom weight configurations only in local component state. When the user adjusts weights and clicks 'Apply Weights', the onChange callback fires (line 41) but there is no persistence mechanism. The weights revert to defaults when the component remounts. The parent ReadabilityDashboard (line 447) only logs the weights to console. Custom weight configurations are lost on page navigation.",
    "steps": "1. Analyze a URL with the AI Readability Checker. 2. On the dashboard, click 'Adjust Weights'. 3. Modify category weights (e.g., set AI Signals to 40%). 4. Click 'Apply Weights'. 5. Navigate away and return to the same analysis. 6. Open the weight config again and observe the weights have reverted to defaults.",
    "expected": "Custom weight configurations should be persisted (via localStorage, Firestore, or user preferences) so that users can maintain their preferred scoring weights across sessions and analyses. The dashboard should recalculate scores when weights change.",
    "actual": "Weights exist only in component state (useState on line 26). The parent's onChange handler (ReadabilityDashboard.jsx:448) only does console.log('Custom weights applied:', weights). There is no persistence and no recalculation of the overall or category scores with the new weights.",
    "impact": "Users who configure custom weights for their industry or use case must re-configure them every time they view an analysis. The feature appears functional but provides no lasting value. Additionally, applying weights has no effect on the displayed scores."
  },
  {
    "bug_id": "R08-B-010",
    "severity": "MEDIUM",
    "category": "Workflow Gap",
    "component": "NotificationPanel - Missing Delete/Clear Functionality",
    "file_line": "src/components/shared/NotificationPanel.jsx:11",
    "description": "The NotificationPanel provides 'Mark all as read' but has no ability to delete individual notifications or clear/archive notification history. The useNotifications hook exposes only markAsRead and markAllAsRead. Over time, the notification list grows unbounded with no way for users to remove stale, irrelevant, or actioned notifications.",
    "steps": "1. Accumulate several notifications by receiving task assignments, mentions, etc. 2. Mark all as read. 3. Attempt to delete a specific notification or clear the notification history. 4. Observe there is no delete or clear option available.",
    "expected": "Users should be able to delete individual notifications (swipe or click delete) and clear all notifications or clear read notifications. There should also be a notification retention policy to automatically remove old notifications.",
    "actual": "The notification panel only supports reading notifications and marking them as read. There is no delete, clear, or archive functionality. Notifications accumulate indefinitely in the list.",
    "impact": "Poor user experience as notification lists become cluttered over time. Users cannot distinguish between actionable and stale notifications. The 'View all notifications' link (line 172) routes to '/notifications' which doesn't appear to have additional management capabilities."
  },
  {
    "bug_id": "R08-B-011",
    "severity": "MEDIUM",
    "category": "Missing Feature",
    "component": "LinkToProjectModal - Unlink Capability",
    "file_line": "src/components/shared/LinkToProjectModal.jsx:55",
    "description": "The LinkToProjectModal allows linking items to projects but provides no mechanism to unlink an item from a project. Once an item is linked (handleLink function, line 55), the 'Linked' badge is shown (line 182) and the button becomes disabled. There is no unlink/remove association button or workflow. This is a missing CRUD operation - the 'Delete' part of linking is absent.",
    "steps": "1. Open a tool item (e.g., audit result). 2. Click 'Link to Project'. 3. Link the item to a project. 4. Observe the project now shows 'Linked' status. 5. Attempt to unlink the item from the project. 6. Note there is no unlink option available.",
    "expected": "Already-linked projects should display an 'Unlink' button or toggle that allows removing the association. The modal should support bidirectional CRUD for project-item links (both link and unlink operations).",
    "actual": "The modal only supports one-way linking. Once linked, the project row shows a green 'Linked' badge and the button is disabled (line 151). There is no unlink action available. The user must manage project links through other means (if available) or cannot remove incorrect links at all.",
    "impact": "Users who accidentally link an item to the wrong project, or who need to reorganize project associations, have no way to correct the linkage. This creates data management problems and reduces the usefulness of the project linking feature."
  },
  {
    "bug_id": "R08-B-012",
    "severity": "MEDIUM",
    "category": "Audit Trail",
    "component": "SchemaLibraryPanel - Delete Without Audit",
    "file_line": "src/components/schema-generator/SchemaLibraryPanel.jsx:82",
    "description": "Schema deletion in the Schema Library uses a browser confirm() dialog and does not log the deletion action. The handleDelete function (line 82) uses confirm() for confirmation and then directly calls deleteSchema. No audit trail entry is created for who deleted which schema and when. In a team environment, this makes it impossible to track schema library changes.",
    "steps": "1. Navigate to the Schema Generator. 2. Open the Schema Library. 3. Delete a saved schema. 4. Confirm the browser dialog. 5. Check for any audit log entry recording the deletion. 6. Attempt to recover the deleted schema.",
    "expected": "Schema deletions should be logged in an audit trail with the user who performed the deletion, the schema name/ID, and timestamp. A proper confirmation modal (consistent with the rest of the application) should be used instead of browser confirm(). Ideally, soft-delete or undo should be supported.",
    "actual": "The handleDelete function (line 82-86) uses browser confirm() (not a styled modal), then calls deleteSchema with no audit logging. The deletion is permanent with no recovery option and no record of who deleted what.",
    "impact": "In team environments, any user can delete shared schemas with no accountability. If a critical schema template is accidentally or maliciously deleted, there is no way to determine who did it or when. The use of browser confirm() is also inconsistent with the application's UI patterns."
  },
  {
    "bug_id": "R08-B-013",
    "severity": "MEDIUM",
    "category": "Data Integrity",
    "component": "useMyTasks - Unfiltered Collection Query",
    "file_line": "src/hooks/useAssignments.js:241",
    "description": "The useMyTasks hook queries the entire 'checklist_assignments' collection with no server-side filtering (line 241). It fetches every assignment document across all projects, then filters client-side to find tasks assigned to the current user (line 252). This is a performance and data exposure issue - the client receives assignment data for all users across all projects.",
    "steps": "1. Log in as any user. 2. Navigate to 'My Tasks'. 3. Observe network requests to Firestore. 4. Note that the query fetches all documents from the checklist_assignments collection with no where() clause.",
    "expected": "The query should use Firestore security rules and a server-side where() clause to only return assignments relevant to the current user. This could be achieved with an array-contains query on the assignedTo field or by restructuring the data to support efficient per-user queries.",
    "actual": "The query on line 241 fetches the entire collection: query(collection(db, 'checklist_assignments')). All assignment data for all projects and all users is downloaded to the client before filtering. The comment on line 239 acknowledges this: 'This is a simplified version'.",
    "impact": "As the application scales, this will cause significant performance degradation, increased Firestore read costs, and potential data exposure where users can access assignment details of other users through browser developer tools. This is both a performance and security concern."
  },
  {
    "bug_id": "R08-B-014",
    "severity": "LOW",
    "category": "Workflow Gap",
    "component": "DueDatesWidget - View All Dead End",
    "file_line": "src/components/shared/DueDatesWidget.jsx:262",
    "description": "The 'View all' button in the DueDatesWidget (displayed when there are more than 5 due dates) has no onClick handler and no navigation target. It renders as a button element with text showing the total count but clicking it does nothing. This is a workflow dead-end where users are informed that more items exist but cannot access them.",
    "steps": "1. Create more than 5 due date items. 2. Observe the DueDatesWidget shows 5 items plus a 'View all (N)' button. 3. Click the 'View all' button. 4. Nothing happens.",
    "expected": "The 'View all' button should navigate to a full due dates management page, expand the widget to show all items, or open a modal with the complete list including sorting and filtering capabilities.",
    "actual": "The button on line 262 is rendered as: <button className=\"...\">View all ({count})</button> with no onClick handler, href, or any interactive behavior. It is a non-functional button.",
    "impact": "Users with many due dates cannot view or manage items beyond the first 5 displayed in the widget. This limits the usefulness of the due dates feature for active project managers who may have dozens of upcoming deadlines."
  },
  {
    "bug_id": "R08-B-015",
    "severity": "LOW",
    "category": "Scope Gap",
    "component": "FeedbackWidget - No Admin Review Interface",
    "file_line": "src/components/shared/FeedbackWidget.jsx:68",
    "description": "The FeedbackWidget collects user feedback and saves it to a 'feedback' Firestore collection with a 'status: new' field (line 78), but there is no corresponding admin interface to review, respond to, or manage feedback submissions. The feedback data is written and never consumed, creating a write-only data sink with no lifecycle management.",
    "steps": "1. Submit feedback via the FeedbackWidget. 2. Verify the feedback is saved to Firestore. 3. Search the application for any admin panel or interface to view submitted feedback. 4. No such interface exists.",
    "expected": "There should be an admin-accessible feedback management interface where team leads or administrators can review submissions, update status (new/in-review/resolved/closed), respond to users, and generate insights from feedback patterns.",
    "actual": "Feedback is collected and stored in Firestore with 'status: new' but no part of the application reads or manages this data. The status field suggests a lifecycle was intended but never implemented. Feedback accumulates indefinitely with no review process.",
    "impact": "User feedback is effectively lost despite being stored. The feedback feature creates a false expectation that submissions will be reviewed and acted upon. Without a management interface, the feature provides no value to the product team and occupies Firestore storage without purpose."
  }
]
