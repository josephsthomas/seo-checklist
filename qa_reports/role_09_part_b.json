[
  {
    "bug_id": "R09-B-001",
    "severity": "CRITICAL",
    "category": "Error Logging",
    "component": "ErrorBoundary",
    "file_line": "src/components/shared/ErrorBoundary.jsx:21",
    "description": "ErrorBoundary only logs errors to console.error in development mode (import.meta.env.DEV). In production, componentDidCatch is effectively a no-op -- errors that crash component trees are silently swallowed with no telemetry, no external error reporting service integration (e.g., Sentry, DataDog, LogRocket), and no server-side logging. This means production runtime errors will be invisible to the engineering and operations teams.",
    "steps": "1. Deploy application to production environment. 2. Trigger a rendering error in any lazy-loaded component (e.g., corrupt API response in ReadabilityDashboard). 3. Observe that the ErrorBoundary catches the error and shows the fallback UI. 4. Check server logs, monitoring dashboards, or any external logging service.",
    "expected": "Production errors caught by ErrorBoundary should be reported to an external error monitoring service (Sentry, Bugsnag, etc.) with stack trace, component stack, user context, and page route.",
    "actual": "In production, componentDidCatch sets state but performs no logging or external reporting. Errors are completely invisible to the operations team.",
    "impact": "Production crashes go undetected. Teams cannot triage, prioritize, or fix production errors. Users experience broken pages with no visibility into frequency or root cause, degrading platform reliability and trust."
  },
  {
    "bug_id": "R09-B-002",
    "severity": "HIGH",
    "category": "Bundle Size",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:33",
    "description": "ReportBuilderPage statically imports both jsPDF and html2canvas at the top level. These are heavyweight libraries (jsPDF ~300KB, html2canvas ~200KB minified) that are only needed when the user clicks 'Export'. They are not listed in vite.config.js manualChunks and not dynamically imported, meaning they are bundled into the main ReportBuilderPage chunk and loaded eagerly when the page mounts, even if the user never exports.",
    "steps": "1. Navigate to the Report Builder page. 2. Open browser DevTools Network tab. 3. Observe the chunk loaded for ReportBuilderPage. 4. Note that jsPDF and html2canvas are included in the chunk even though no export has been triggered.",
    "expected": "jsPDF and html2canvas should be dynamically imported (import()) inside the exportReport function, only loaded when the user actually triggers an export operation.",
    "actual": "Both libraries are statically imported at the top of the file (lines 33-34), increasing the initial chunk size by approximately 500KB for all users who visit the Report Builder, regardless of whether they export.",
    "impact": "Unnecessarily inflated bundle size for the Report Builder page. Slower initial page load, especially on mobile or slow connections. This directly impacts Core Web Vitals (LCP, TTI) for a page that may be frequently visited by project managers."
  },
  {
    "bug_id": "R09-B-003",
    "severity": "HIGH",
    "category": "Deploy Risk",
    "component": "SEO Configuration",
    "file_line": "src/config/seo.js:9",
    "description": "The site URL is hardcoded as 'https://contentstrategyportal.com' with a TODO comment 'Update with actual domain'. This value is used for all canonical URLs, Open Graph meta tags, Twitter Card URLs, schema.org JSON-LD, breadcrumb schemas, and HowTo schema throughout the application. If the actual production domain differs (e.g., staging, preview deployments, or a different production domain), all SEO metadata will point to an incorrect or non-existent domain.",
    "steps": "1. Open src/config/seo.js. 2. Observe SITE_URL is hardcoded to 'https://contentstrategyportal.com'. 3. Deploy to staging or a preview environment. 4. Inspect <head> meta tags -- all canonical URLs, og:url, and schema.org markup reference the hardcoded domain.",
    "expected": "SITE_URL should be sourced from an environment variable (e.g., import.meta.env.VITE_SITE_URL) with the hardcoded value as a fallback. This enables correct canonical URLs and schema markup across all deployment environments.",
    "actual": "SITE_URL is a hardcoded constant string. There is no environment variable override. All environments (dev, staging, production) generate SEO metadata pointing to 'https://contentstrategyportal.com'.",
    "impact": "Staging and preview deployments generate incorrect canonical URLs, potentially causing search engine indexing issues. If the production domain is different from the hardcoded value, all SEO meta tags, Open Graph tags, and structured data will reference a non-existent URL, harming search visibility and social sharing."
  },
  {
    "bug_id": "R09-B-004",
    "severity": "HIGH",
    "category": "Monitoring Gap",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:448",
    "description": "The ReadabilityWeightConfig onChange handler contains a console.log statement: console.log('Custom weights applied:', weights). This is debug logging left in production code. More critically, there is no actual weight application logic -- the onChange callback only logs and does nothing else. When users adjust weights via the UI, the changes are silently discarded.",
    "steps": "1. Navigate to a completed readability analysis. 2. Open the 'Score Details' tab. 3. Click 'Adjust Weights'. 4. Modify any weight slider. 5. Observe that scores do not recalculate and the console shows the log message.",
    "expected": "Weight changes should trigger a score recalculation. The console.log should be removed from production code and replaced with actual weight application logic or at minimum a monitoring event.",
    "actual": "The onChange handler only calls console.log. Weights are never applied. The debug statement ships to production.",
    "impact": "Users who attempt to customize scoring weights see no effect, leading to confusion and perceived broken functionality. The console.log pollutes production logs and leaks implementation details. The feature appears broken from a user perspective."
  },
  {
    "bug_id": "R09-B-005",
    "severity": "HIGH",
    "category": "Code Splitting",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:11",
    "description": "ReadabilityDashboard uses React.lazy for ReadabilityCategoryChart and ReadabilityLLMPreview, but eagerly imports seven other large components (ReadabilityRecommendations, ReadabilityIssuesTable, ReadabilityCrossToolLinks, ReadabilityPDFPreview, ReadabilityQuotableHighlighter, ReadabilityWeightConfig, ReadabilityScoreCard) that are displayed conditionally based on tab selection. Only one tab panel is visible at a time, yet all tab components are loaded upfront. Additionally, ReadabilityPDFPreview (which internally imports heavy PDF generation libraries) is eagerly imported even though it only renders when the user clicks 'Export as PDF'.",
    "steps": "1. Open the ReadabilityDashboard component. 2. Observe that only ReadabilityCategoryChart and ReadabilityLLMPreview use lazy(). 3. Components for inactive tabs (recommendations, issues) and modals (PDF preview, weight config) are statically imported. 4. Check bundle analyzer output for the ReadabilityDashboard chunk.",
    "expected": "Tab content components should be lazily loaded. At minimum, ReadabilityPDFPreview (which gates PDF export libraries), ReadabilityWeightConfig, and the per-tab components should use React.lazy or dynamic import to avoid loading unused code.",
    "actual": "Only 2 of 9 imported child components use lazy loading. The remaining 7 are statically imported and bundled into the ReadabilityDashboard chunk, including modal components that may never render.",
    "impact": "Inflated chunk size for the readability results page, which is the most frequently visited page in the readability workflow. Slower time-to-interactive on the results page, degrading user experience especially on repeat analyses."
  },
  {
    "bug_id": "R09-B-006",
    "severity": "MEDIUM",
    "category": "Code Splitting",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:10",
    "description": "ReadabilityDashboard uses bare React.lazy() for sub-component lazy loads (ReadabilityCategoryChart on line 10, ReadabilityLLMPreview on line 12) instead of the application's lazyWithRetry utility. The App.jsx file consistently uses lazyWithRetry for all route-level lazy loads to provide automatic retry logic for chunk loading failures. These sub-component lazy imports bypass that pattern, making them vulnerable to transient network failures without retry.",
    "steps": "1. Load the ReadabilityDashboard results page. 2. Throttle the network to simulate an unreliable connection. 3. Observe that ReadabilityCategoryChart or ReadabilityLLMPreview fails to load on the first attempt. 4. Compare with route-level components that use lazyWithRetry and successfully retry.",
    "expected": "Sub-component lazy imports should use lazyWithRetry(() => import('./ReadabilityCategoryChart'), 'ReadabilityCategoryChart') to get automatic retry on chunk load failures, consistent with the app-wide pattern.",
    "actual": "Lines 10 and 12 use bare lazy(() => import(...)) instead of lazyWithRetry(() => import(...)). If the chunk fails to load, there is no retry and the user immediately sees an error boundary fallback.",
    "impact": "Users on unreliable networks may see broken dashboard sections (blank chart area, broken LLM preview) that could have been recovered with automatic retries, reducing perceived reliability of the readability tool."
  },
  {
    "bug_id": "R09-B-007",
    "severity": "MEDIUM",
    "category": "Build Issue",
    "component": "Vite Configuration",
    "file_line": "vite.config.js:25",
    "description": "The chunkSizeWarningLimit is set to 600KB, which is 20% above Vite's default of 500KB. The comment states 'Increase warning limit since we have lazy loading', but this masks genuine bundle size problems. Several dependencies are missing from manualChunks configuration: html2canvas (used in ReportBuilderPage), chart.js and react-chartjs-2 (used across multiple dashboard components), mammoth (used for document parsing), pdfjs-dist (used for PDF preview), and react-markdown. These libraries will be bundled into their respective component chunks without dedicated vendor splitting.",
    "steps": "1. Run 'vite build'. 2. Observe the build output for chunk sizes. 3. Note that html2canvas, chart.js, react-chartjs-2, mammoth, pdfjs-dist are not listed in manualChunks. 4. Verify that the 600KB warning limit suppresses warnings for oversized chunks.",
    "expected": "manualChunks should include all heavy vendor libraries (html2canvas, chart.js, react-chartjs-2, pdfjs-dist, mammoth, react-markdown). The chunkSizeWarningLimit should remain at the default 500KB to surface genuine problems. Each heavy vendor should be in its own chunk for optimal caching.",
    "actual": "Only 5 vendor groups are defined in manualChunks. At least 6 heavy dependencies are missing. The elevated warning limit hides chunk size violations.",
    "impact": "Suboptimal bundle splitting leads to larger-than-necessary downloads when users navigate to pages using these unlisted dependencies. Browser cache invalidation is also suboptimal -- updating any component that shares a chunk with chart.js forces re-download of chart.js even if it has not changed."
  },
  {
    "bug_id": "R09-B-008",
    "severity": "MEDIUM",
    "category": "Error Logging",
    "component": "AuthContext",
    "file_line": "src/contexts/AuthContext.jsx:217",
    "description": "The fetchUserProfile function silently catches and ignores all errors with an empty catch block: 'catch { // Silently fail - profile will be null }'. Similarly, the deleteAccount storage cleanup at line 187 uses an empty catch block. When Firestore is unavailable, has permission errors, or has network issues, the user profile fetch failure is completely invisible. The user will see the app in a degraded state (no profile data, no role information) with no error indication, no logging, and no monitoring alert.",
    "steps": "1. Simulate a Firestore outage or permission error (e.g., modify security rules). 2. Log in to the application. 3. Observe that user profile is null (no role, no name, no avatar). 4. Check any logging or monitoring -- no error is recorded.",
    "expected": "Profile fetch failures should be logged (at minimum console.error, ideally to an external monitoring service). The user should see a graceful degradation message or retry mechanism. The catch block should differentiate between 'no profile exists' vs 'Firestore error'.",
    "actual": "All errors are silently swallowed. The user sees a degraded experience (null profile, default role) with no explanation and no way for the team to diagnose the issue.",
    "impact": "Users may lose access to role-gated features (like the readability checker, which checks canRunReadabilityCheck permission) because their role defaults to 'content_writer' when the profile fails to load. Operations team has no visibility into profile loading failures."
  },
  {
    "bug_id": "R09-B-009",
    "severity": "MEDIUM",
    "category": "Dependency Risk",
    "component": "Package Configuration",
    "file_line": "package.json:23",
    "description": "The lucide-react dependency is pinned to version '^0.294.0', which is a pre-1.0 release. Pre-1.0 semver ranges with caret (^) allow minor version upgrades that may include breaking changes per semver conventions for pre-1.0 packages. lucide-react is used extensively throughout the entire application (every component imports icons from it). A breaking change in icon names, props, or tree-shaking behavior could break the entire UI across all components simultaneously during npm install or CI builds.",
    "steps": "1. Open package.json. 2. Observe lucide-react version is '^0.294.0'. 3. Run 'npm install' in a fresh environment. 4. If a newer 0.x version has been published with breaking changes (icon renames, removed icons, changed exports), the install will pull it in.",
    "expected": "lucide-react should be pinned to an exact version (e.g., '0.294.0') or the caret range should be replaced with a tilde ('~0.294.0') to prevent unexpected breaking changes. Alternatively, upgrade to a stable 1.x release if available.",
    "actual": "The caret range allows any 0.x.y version >= 0.294.0 to be installed, which under pre-1.0 semver conventions may include breaking changes in 0.295.0+.",
    "impact": "Non-deterministic builds. CI/CD pipeline or fresh installations may pull a breaking version, causing widespread icon rendering failures across every page of the application. This is a deployment risk for any environment that does not use a lockfile or has a stale lockfile."
  },
  {
    "bug_id": "R09-B-010",
    "severity": "MEDIUM",
    "category": "Environment Issue",
    "component": "lazyWithRetry",
    "file_line": "src/utils/lazyWithRetry.js:32",
    "description": "The lazyWithRetry utility uses a fixed 1-second retry delay (RETRY_DELAY = 1000ms) with no exponential backoff. When a chunk fails to load (e.g., during a deployment with cache invalidation), all 3 retries fire at the same 1-second interval. This provides no relief for transient network issues or CDN propagation delays. Additionally, there is no mechanism to force a page reload when chunk loading ultimately fails after retries -- which is the standard recovery mechanism when a new deployment invalidates old chunk hashes.",
    "steps": "1. Deploy a new version of the application that changes chunk hashes. 2. A user with the old version cached navigates to a lazy-loaded route. 3. The old chunk URL 404s. 4. lazyWithRetry retries 3 times at 1-second intervals. 5. All retries fail because the old chunk no longer exists. 6. User sees the ErrorBoundary fallback with no automatic recovery.",
    "expected": "Retry logic should use exponential backoff (e.g., 1s, 2s, 4s). After all retries fail for a ChunkLoadError, the utility should trigger a hard page reload (window.location.reload()) to fetch the updated HTML with new chunk references. This is the standard pattern for handling chunk loading failures after deployments.",
    "actual": "Fixed 1s retry delay with no backoff. No page reload fallback. After 3 failed retries, the error propagates to ErrorBoundary and the user is stuck.",
    "impact": "During deployments, users with stale cached HTML will encounter chunk loading failures that never self-heal. They must manually refresh the page to recover, leading to support tickets and user frustration. This is especially impactful for single-page apps where users may keep tabs open for extended periods."
  },
  {
    "bug_id": "R09-B-011",
    "severity": "MEDIUM",
    "category": "Monitoring Gap",
    "component": "ReadabilityShareView",
    "file_line": "src/components/readability/ReadabilityShareView.jsx:98",
    "description": "The ReadabilityShareView is a public-facing page (no auth required) that loads shared analysis reports. When PDF export fails on this public page, the error is only logged to console.error (line 98). There is no user-facing error notification (no toast, no error state) and no monitoring/analytics event. Since this is a public page used for sharing reports with clients and stakeholders, failures here have direct business impact but zero visibility.",
    "steps": "1. Open a shared readability analysis via its public URL. 2. Click 'Download PDF Report'. 3. Simulate a PDF generation failure (e.g., network error, missing fonts). 4. Observe that the error is logged to console.error but no toast or error message is shown to the user.",
    "expected": "PDF export failures on the shared view should show a user-facing error message (toast or inline alert). The failure should also be tracked via analytics/monitoring since this is a public-facing feature that reflects on the platform's credibility.",
    "actual": "console.error is called but no user-visible feedback is provided. The user clicks the button, sees a loading state, and then nothing happens -- the button returns to its idle state with no indication of failure.",
    "impact": "Clients and stakeholders attempting to download PDF reports from shared links experience silent failures, damaging the platform's professional credibility. No monitoring means the team cannot track how often this occurs."
  },
  {
    "bug_id": "R09-B-012",
    "severity": "MEDIUM",
    "category": "Caching Gap",
    "component": "storageHelpers",
    "file_line": "src/utils/storageHelpers.js:67",
    "description": "When localStorage quota is exceeded (QuotaExceededError), the recovery strategy is to remove STORAGE_KEYS.RECENT_ACTIVITY and retry the write. This approach has several issues: (1) It only evicts one specific key, ignoring potentially larger data stores like ITEM_TIMELINE_DATA or TIME_ENTRIES. (2) It does not assess which key is consuming the most space before evicting. (3) The checkStorageUsage function exists but is never called during quota recovery to make an informed eviction decision. (4) There is no proactive quota management -- the system only reacts after writes fail, by which point user data may already be lost.",
    "steps": "1. Fill localStorage near its limit using the application (many projects, time entries, timeline data). 2. Attempt to save a new filter preset or time entry. 3. Observe the QuotaExceededError handler at line 67. 4. Note that it blindly removes RECENT_ACTIVITY regardless of whether that frees enough space.",
    "expected": "The quota recovery strategy should: (1) Call checkStorageUsage() to identify the largest stored items. (2) Evict the least-critical or largest items first. (3) Implement LRU eviction for timeline data. (4) Proactively warn users when approaching quota limits. (5) Consider compressing stored data.",
    "actual": "Only RECENT_ACTIVITY is evicted. If that key is small or empty, the retry still fails. No intelligent eviction strategy exists despite checkStorageUsage being available.",
    "impact": "Power users with many projects may hit storage quota limits and experience data loss or persistent write failures. Critical data (timeline, time entries) may be silently unwritable while less important data remains in storage."
  },
  {
    "bug_id": "R09-B-013",
    "severity": "MEDIUM",
    "category": "Caching Gap",
    "component": "ReadabilityInputScreen",
    "file_line": "src/components/readability/ReadabilityInputScreen.jsx:292",
    "description": "The first-use onboarding callout directly accesses localStorage.getItem('readability-onboarded') during render without using the storageHelpers utility and without try/catch error handling. If localStorage is unavailable (private browsing in some browsers, storage quota exceeded, or SSR context), this will throw an unhandled exception during render. Additionally, the key 'readability-onboarded' is not registered in STORAGE_KEYS in storageHelpers.js, bypassing the centralized storage management, quota tracking, and export/import functionality.",
    "steps": "1. Open ReadabilityInputScreen in a browser with localStorage disabled or in an incognito window with storage restrictions. 2. Observe that the component may throw during render on line 292. 3. Search STORAGE_KEYS in storageHelpers.js and confirm 'readability-onboarded' is not registered.",
    "expected": "The localStorage access should use the getStorageItem/setStorageItem helpers from storageHelpers.js with proper error handling. The key should be registered in STORAGE_KEYS for centralized management and storage quota tracking.",
    "actual": "Raw localStorage.getItem/setItem is used without try/catch, bypassing the centralized storage system. The key is untracked by the storage quota monitoring system.",
    "impact": "Potential render crash in environments where localStorage is unavailable. The onboarding state is invisible to the storage export/import, quota monitoring, and data cleanup features, creating inconsistent behavior during data migration or backup/restore."
  },
  {
    "bug_id": "R09-B-014",
    "severity": "LOW",
    "category": "Error Logging",
    "component": "useCustomChecklistItems",
    "file_line": "src/hooks/useCustomChecklistItems.js:39",
    "description": "The Firestore onSnapshot listener in useCustomChecklistItems does not handle errors via the onSnapshot error callback. The onSnapshot function accepts an optional error handler as its third argument (or via the observer object), but here only the success callback is provided. If the Firestore subscription encounters a permission error, network disconnection, or quota limit, the error will be unhandled and the loading state will remain true indefinitely, leaving users in a perpetual loading state.",
    "steps": "1. Create a project with custom checklist items. 2. Simulate a Firestore permission change (e.g., modify security rules to deny reads). 3. Navigate to the checklist page with custom items. 4. Observe that the component shows a loading state indefinitely with no error message.",
    "expected": "onSnapshot should include an error callback: onSnapshot(q, successCallback, errorCallback) that sets loading to false and surfaces the error to the user.",
    "actual": "Only the success callback is provided to onSnapshot. Firestore errors result in an infinite loading state with no error handling.",
    "impact": "Users may encounter a perpetual loading spinner with no way to recover when Firestore subscription errors occur. No diagnostic information is available for troubleshooting."
  },
  {
    "bug_id": "R09-B-015",
    "severity": "LOW",
    "category": "Build Issue",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:362",
    "description": "The HTML export function in ReportBuilderPage constructs an HTML string using template literals with unsanitized user input (reportName). The report name is interpolated directly into the HTML title tag and h1 element without HTML entity encoding. If a user enters a report name containing HTML special characters (e.g., '<script>alert(1)</script>'), the exported HTML file will contain executable scripts. While this is a downloaded file (not served from the application), it could be exploited if the exported HTML is hosted on a web server.",
    "steps": "1. In the Report Builder, set report name to '<img src=x onerror=alert(1)>'. 2. Click Export > Export as HTML. 3. Open the exported HTML file in a browser. 4. Observe that the injected HTML is rendered/executed.",
    "expected": "User-supplied strings interpolated into HTML templates should be HTML-entity-encoded to prevent XSS in exported files.",
    "actual": "reportName is interpolated directly into the HTML template string without any sanitization or encoding.",
    "impact": "While limited to exported files (not the application itself), if exported HTML reports are shared or hosted, they could execute arbitrary scripts. This is a secondary risk but worth addressing for defense in depth."
  },
  {
    "bug_id": "R09-B-016",
    "severity": "LOW",
    "category": "Monitoring Gap",
    "component": "FeedbackWidget",
    "file_line": "src/components/shared/FeedbackWidget.jsx:83",
    "description": "The FeedbackWidget catches submission errors with an empty catch block that only shows a toast message ('Failed to submit feedback. Please try again.'). There is no console.error, no error logging, and no monitoring event. For a feature specifically designed to collect user feedback (including bug reports), the irony is that bug report submission failures themselves are completely invisible to the team. Additionally, the error object is not logged, so there is no way to distinguish between network failures, Firestore permission issues, or quota limits.",
    "steps": "1. Open the Feedback Widget. 2. Fill in feedback and click Submit. 3. Simulate a Firestore write failure (network disconnect or permission error). 4. Observe that the toast shows 'Failed to submit feedback' but no error details are logged anywhere.",
    "expected": "Feedback submission failures should at minimum log the error to console.error with the error object. Ideally, failed feedback submissions should be queued in localStorage for retry, or logged to an alternative endpoint.",
    "actual": "The catch block shows a toast but discards the error object entirely. No logging, no retry, no monitoring.",
    "impact": "User bug reports and feedback may be silently lost during outages. The team has no visibility into feedback submission failure rates, which is especially problematic for a feature that is the primary user-to-team communication channel."
  }
]
