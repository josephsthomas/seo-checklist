[
  {
    "bug_id": "R10-B-001",
    "severity": "HIGH",
    "category": "Flow Break",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:80",
    "description": "The ReportBuilderPage tracks unsaved changes via hasUnsavedChanges state but never registers a beforeunload listener to warn users when navigating away from the page with unsaved report layouts. The hasUnsavedChanges flag is set correctly on widget additions, moves, resizes, and name changes, but if the user clicks a navigation link or browser back button, all unsaved work is silently lost.",
    "steps": "1. Open the Report Builder page. 2. Add several widgets and arrange them. 3. Do NOT click Save. 4. Click any navigation link (e.g., Home). 5. Observe that the page navigates away without any warning.",
    "expected": "A browser beforeunload prompt or in-app confirmation dialog should appear warning the user about unsaved changes and giving them the option to stay on the page or discard changes.",
    "actual": "Navigation proceeds silently and all unsaved report layout work is permanently lost without any warning.",
    "impact": "Users who invest significant time building complex report layouts can lose all their work by accidentally navigating away, leading to frustration and lost productivity."
  },
  {
    "bug_id": "R10-B-002",
    "severity": "HIGH",
    "category": "Form UX Issue",
    "component": "UserSettingsPage",
    "file_line": "src/components/settings/UserSettingsPage.jsx:179",
    "description": "The profile form in UserSettingsPage has no client-side validation for the Full Name field. The form allows submission of an empty name or whitespace-only string. The handleSaveProfile function proceeds directly to updating Firebase Auth and Firestore without checking if the name field is populated. This can result in the user's display name being set to an empty string.",
    "steps": "1. Navigate to Settings > Profile. 2. Clear the Full Name field entirely. 3. Click Save Changes. 4. Observe that the profile saves with an empty name.",
    "expected": "The form should validate that the Full Name field is not empty/whitespace-only before submitting, showing an inline validation error like 'Name is required' and preventing submission.",
    "actual": "The form submits successfully with an empty name, updating the user's display name to an empty string in Firebase, which can cause display issues throughout the application.",
    "impact": "User names are displayed across the app in comments, assignments, team views, and activity feeds. An empty name breaks the visual identity and creates confusion for team members."
  },
  {
    "bug_id": "R10-B-003",
    "severity": "HIGH",
    "category": "Undo Missing",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:174",
    "description": "The Report Builder allows users to delete widgets (removeWidget function at line 174) with a single click and no confirmation dialog or undo capability. Unlike the ScheduledReportsPanel which implements both a confirmation dialog and an undo toast for deletions, the Report Builder's widget deletion is immediate and irreversible. The same issue applies to the Delete Widget button in the settings sidebar at line 1021.",
    "steps": "1. Open Report Builder and add several widgets with custom configurations. 2. Click the trash icon on any widget in the control bar. 3. Observe the widget is immediately deleted. 4. There is no way to undo or recover the deleted widget.",
    "expected": "Widget deletion should either show a confirmation dialog before removing, or provide an undo toast notification (similar to ScheduledReportsPanel's confirmDelete at line 192-207) allowing the user to restore the widget within a few seconds.",
    "actual": "Widget is immediately and permanently removed on single click with no confirmation or undo mechanism.",
    "impact": "Users can accidentally delete carefully configured widgets (with custom data sources, chart types, and positioning) and must recreate them from scratch, wasting time on complex report layouts."
  },
  {
    "bug_id": "R10-B-004",
    "severity": "MEDIUM",
    "category": "Missing Error State",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:57",
    "description": "The ReadabilityDashboard loads trend data via historyHook.getTrendData() in a useEffect at line 55-60 but has no error handling for the async operation. If getTrendData rejects, the promise is unhandled since there is no .catch() chain. Additionally, the share feature (handleShare at line 119) silently fails if shareHook.createShareLink returns no result or throws - there is no error feedback displayed to the user when share link creation fails.",
    "steps": "1. Open a readability analysis result. 2. Simulate a network failure or API error. 3. The trend data section loads without any indication of failure. 4. Click Share and attempt to create a share link while network is down. 5. Observe no error feedback is shown.",
    "expected": "Both trend data loading and share link creation should have error handling that shows the user a meaningful error message (e.g., an error toast or inline error) when operations fail.",
    "actual": "Trend data errors are silently swallowed (no .catch()), and share link errors show no user-facing feedback. The share dialog simply stays open with no indication of failure.",
    "impact": "Users have no visibility into why trend data is missing or why share link creation failed, leading to confusion and inability to troubleshoot network or permission issues."
  },
  {
    "bug_id": "R10-B-005",
    "severity": "MEDIUM",
    "category": "Form UX Issue",
    "component": "ScheduledReportsPanel",
    "file_line": "src/components/reports/ScheduledReportsPanel.jsx:930",
    "description": "The recipients field in the ScheduleFormModal accepts comma-separated email addresses as free text (line 930) but performs no email format validation. The handleSubmit function (line 645) only checks that the recipients string is not empty (trim check), then splits by comma and saves. Invalid email formats like 'not-an-email', 'user@', or '@@invalid' are accepted without any validation, which would cause delivery failures when the scheduled report runs.",
    "steps": "1. Open Scheduled Reports and click New Schedule. 2. Complete steps 1 and 2. 3. On Step 3 (Delivery), enter 'invalid-email, @bad, user' in the Recipients field. 4. Click Create Schedule. 5. Observe the schedule is created successfully with invalid email addresses.",
    "expected": "The form should validate each email address against a standard email pattern, showing inline validation errors for malformed addresses and preventing form submission until all emails are valid.",
    "actual": "The form accepts any text as recipient emails without validation, allowing creation of scheduled reports with invalid delivery addresses that will fail silently when reports are generated.",
    "impact": "Scheduled reports will fail to deliver to invalid email addresses, and users won't discover the issue until they miss expected report deliveries, potentially weeks later."
  },
  {
    "bug_id": "R10-B-006",
    "severity": "MEDIUM",
    "category": "Feedback Gap",
    "component": "ReadabilityWeightConfig",
    "file_line": "src/components/readability/ReadabilityWeightConfig.jsx:40",
    "description": "The ReadabilityWeightConfig component allows users to adjust category weights via sliders and apply them, but the Apply Weights button (handleApply at line 40) only calls onChange with the new weights and provides no user feedback. There is no toast notification, no visual confirmation animation, and no indication that the score has been recalculated with the new weights. Furthermore, the component is rendered in ReadabilityDashboard with onChange set to only console.log (line 448-449), meaning the weight changes have no actual effect on the displayed scores.",
    "steps": "1. Open a readability analysis result. 2. Click the 'Adjust Weights' button in the Score Details tab. 3. Move several weight sliders to new values ensuring total equals 100%. 4. Click 'Apply Weights'. 5. Observe no visible change in scores or confirmation.",
    "expected": "Clicking Apply Weights should: (1) provide a success toast or visual confirmation, (2) actually recalculate and update the displayed scores based on the new weights, and (3) indicate which scores changed.",
    "actual": "The Apply Weights button calls onChange which only console.logs the weights. The scores on the dashboard do not update, and there is no feedback to the user that anything happened.",
    "impact": "The weight configuration feature appears broken to users. They invest time adjusting weights but see no result, leading them to believe the feature is non-functional and eroding trust in the tool."
  },
  {
    "bug_id": "R10-B-007",
    "severity": "MEDIUM",
    "category": "Navigation Dead-End",
    "component": "SchemaGeneratorPage",
    "file_line": "src/components/schema-generator/SchemaGeneratorPage.jsx:117",
    "description": "The SchemaGeneratorPage error view (VIEWS.ERROR, line 117-135) renders a full-screen error state with only a 'Try Again' button that resets to the input view. There is no way for the user to navigate back to the home page, access other tools, or reach any navigation element. The error view replaces the entire page including the main navigation, creating a dead-end where the only option is to retry the same operation that just failed.",
    "steps": "1. Navigate to the Schema Generator. 2. Submit content that triggers a processing error (e.g., malformed HTML that fails parsing). 3. Observe the full-screen error page. 4. Note there is no navigation, no header, and no link to go elsewhere - only 'Try Again'.",
    "expected": "The error view should either preserve the app's main navigation header, or include additional navigation options like 'Go Home' or 'Back to Dashboard' so users are not trapped in a dead-end error screen.",
    "actual": "The error view is a completely standalone full-screen layout with a single 'Try Again' button. Users must use the browser back button to escape, which is not discoverable for all users.",
    "impact": "Users encountering persistent errors are effectively trapped on the error screen with no in-app navigation options, forcing them to use browser controls which may not preserve their session state."
  },
  {
    "bug_id": "R10-B-008",
    "severity": "MEDIUM",
    "category": "Missing Loading State",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:255",
    "description": "The saveReport function (line 255-280) performs async operations (createReport/updateReport) but the save button (line 662-670) has no loading state indicator. While the button is disabled when there are no unsaved changes, during the actual save operation there is no spinner, disabled state, or visual feedback that the save is in progress. If the save takes time (e.g., slow network), users may click repeatedly or navigate away thinking nothing happened.",
    "steps": "1. Open Report Builder and make changes to a report. 2. Click the Save button. 3. Observe the button has no loading spinner or disabled state during the save operation. 4. On a slow connection, the button remains clickable, allowing multiple saves.",
    "expected": "The Save button should show a loading spinner and be disabled while the save operation is in progress, similar to how other components (UserSettingsPage, SchemaLibraryPanel) handle async saves.",
    "actual": "The Save button shows no loading state during the async save operation. There is no 'saving' state variable and the button remains interactive, potentially allowing duplicate submissions.",
    "impact": "Users have no feedback that their save operation is in progress, leading to duplicate submissions on slow networks and uncertainty about whether data was saved successfully."
  },
  {
    "bug_id": "R10-B-009",
    "severity": "MEDIUM",
    "category": "Edge Case",
    "component": "ReadabilityInputScreen",
    "file_line": "src/components/readability/ReadabilityInputScreen.jsx:292",
    "description": "The first-use onboarding callout (line 292-315) reads from localStorage synchronously during render with localStorage.getItem('readability-onboarded'). This has two edge cases: (1) In SSR or environments where localStorage is unavailable, this will throw a ReferenceError crashing the component, and (2) The dismiss handler (line 305-309) calls setActiveTab(activeTab) as a hack to force re-render, which is unreliable and doesn't actually cause a re-render since the state value doesn't change. The dismiss button writes to localStorage but the component won't visually update.",
    "steps": "1. Clear localStorage and navigate to Readability Checker. 2. Observe the onboarding callout appears. 3. Click 'Dismiss'. 4. Observe the callout may not disappear until the next full page refresh because the re-render hack is ineffective.",
    "expected": "The dismiss button should use a dedicated state variable (e.g., useState for 'dismissed') that reliably triggers a re-render when clicked, and the localStorage access should be wrapped in a try/catch for safety.",
    "actual": "The dismiss handler relies on setActiveTab(activeTab) which sets the same value and may not trigger a re-render in React. The onboarding callout may persist until the user navigates away and returns.",
    "impact": "Users who dismiss the onboarding callout see it remain on screen, creating a frustrating experience where the dismiss action appears non-functional."
  },
  {
    "bug_id": "R10-B-010",
    "severity": "MEDIUM",
    "category": "Onboarding Gap",
    "component": "InteractiveTutorial",
    "file_line": "src/components/tutorials/InteractiveTutorial.jsx:265",
    "description": "The InteractiveTutorial component does not include a tutorial for the AI Readability Checker tool. The TUTORIALS constant (line 16-183) defines tutorials for planner, audit, accessibility, image-alt, meta-generator, and schema-generator, but the readability tool - one of the most complex tools with three input methods, multiple tabs, and advanced options - has no tutorial. The readability input screen has a minimal onboarding callout, but there is no step-by-step interactive tutorial for this tool.",
    "steps": "1. Navigate to the tutorials/help section. 2. Review available tutorials. 3. Note that AI Readability Checker has no tutorial. 4. Navigate to the Readability tool and notice there is no option to start a guided tutorial.",
    "expected": "The AI Readability Checker, being a complex multi-step tool with three input methods (URL, upload, paste), advanced options, and four results tabs, should have an interactive tutorial guiding new users through the workflow.",
    "actual": "No tutorial exists for the AI Readability Checker. The only onboarding is a dismissible text callout on the input screen that provides no interactive guidance.",
    "impact": "New users discovering the readability tool face a steep learning curve without guided help, potentially missing key features like advanced options, weight configuration, LLM preview, and cross-tool links."
  },
  {
    "bug_id": "R10-B-011",
    "severity": "LOW",
    "category": "Missing Empty State",
    "component": "ReadabilityHistory",
    "file_line": "src/components/readability/ReadabilityHistory.jsx:174",
    "description": "The ReadabilityHistory component properly handles the initial empty state (no analyses at all, line 174-185) and the loading state (line 154-171), but does not handle the 'no search results' empty state when a user searches and gets no matches. When the search input has a value but filters return no results, the component renders an empty <div className='space-y-2'></div> with no visible feedback to the user. The empty state check at line 174 excludes search results by checking !searchInput && !filters?.searchUrl.",
    "steps": "1. Navigate to the Readability History section with several past analyses. 2. Type a search query that matches no existing URLs (e.g., 'xyznonexistent.com'). 3. Observe the history list becomes empty with no message explaining there are no results.",
    "expected": "When a search query returns no results, the component should display an empty state message like 'No analyses found matching your search' with a suggestion to clear the search filter.",
    "actual": "The history list area becomes blank/empty with no feedback message, leaving the user unsure if the search is still loading or if there truly are no matches.",
    "impact": "Users searching for specific analyses see a confusing blank space instead of a helpful 'no results' message, reducing confidence in the search functionality."
  },
  {
    "bug_id": "R10-B-012",
    "severity": "LOW",
    "category": "Feedback Gap",
    "component": "NotificationPanel",
    "file_line": "src/components/shared/NotificationPanel.jsx:173",
    "description": "The NotificationPanel footer contains a 'View all notifications' link that navigates to '/notifications' (line 173), but there is no evidence that a /notifications route exists in the application. This creates a navigation to a potentially non-existent page. Additionally, the notification panel does not show any loading state while notifications are being fetched from the useNotifications hook - the panel opens and either shows notifications or the empty state immediately, with no indication that data might still be loading.",
    "steps": "1. Trigger several notifications in the app. 2. Open the notification bell dropdown. 3. Click 'View all notifications' at the bottom. 4. Observe where the link navigates to. 5. Also note there is no loading spinner when the panel first opens.",
    "expected": "The 'View all notifications' link should navigate to a valid route that exists in the application. The panel should also show a brief loading state while notifications are being fetched.",
    "actual": "The link navigates to '/notifications' which may not be a defined route, potentially showing a 404 page or blank screen. There is no loading indicator when the panel opens.",
    "impact": "Users clicking 'View all notifications' may land on a dead page, and the lack of loading state on the panel can cause users to think there are no notifications when data is still loading."
  },
  {
    "bug_id": "R10-B-013",
    "severity": "MEDIUM",
    "category": "Form UX Issue",
    "component": "ScheduledReportsPanel",
    "file_line": "src/components/reports/ScheduledReportsPanel.jsx:1002",
    "description": "The ScheduleFormModal has a multi-step form (3 steps) but the Continue button (line 1002-1009) does not validate the current step before advancing. On Step 1, users can proceed without entering a schedule name. On Step 2, users can proceed with default values without reviewing them. Validation only occurs at the final Submit on Step 3 (line 645-655), but by then users have to navigate back through steps to fix issues. The step navigation also allows jumping directly to any step via the step indicators (line 729-741), bypassing intermediate steps.",
    "steps": "1. Open New Schedule modal. 2. Leave the Schedule Name blank on Step 1. 3. Click Continue - navigation proceeds to Step 2 without validation. 4. Click Continue again to reach Step 3. 5. Leave recipients empty and click Create Schedule. 6. Error toast appears, but user must navigate back to Step 1 to fix the name.",
    "expected": "Each step should validate its required fields before allowing the user to proceed. Step 1 should require a name, Step 3 should validate recipients. Inline validation errors should be shown at the step where the issue occurs.",
    "actual": "No per-step validation occurs. Users can advance through all three steps with empty required fields, only to be told about errors on the final step, requiring backward navigation to fix them.",
    "impact": "Users waste time completing a multi-step form only to discover required field errors at the end, creating a frustrating back-and-forth experience that could be prevented with step-level validation."
  },
  {
    "bug_id": "R10-B-014",
    "severity": "HIGH",
    "category": "Missing Error State",
    "component": "SchemaLibraryPanel",
    "file_line": "src/components/schema-generator/SchemaLibraryPanel.jsx:82",
    "description": "The handleDelete function in SchemaLibraryPanel (line 82-86) calls deleteSchema but has no error handling. If the async deleteSchema operation fails (e.g., network error, permission denied), the error is unhandled and the UI provides no feedback to the user. The function uses window.confirm() for confirmation (line 83) which is a native browser dialog that cannot be styled, does not match the application's design language, and is a poor UX pattern compared to the custom confirmation dialogs used elsewhere (e.g., ScheduledReportsPanel). Additionally, there is no undo capability for schema deletion.",
    "steps": "1. Open the Schema Library panel. 2. Click the delete button on any saved schema. 3. A native browser confirm() dialog appears (inconsistent with app styling). 4. Click OK. 5. If the deletion fails due to a network error, no error message is shown. 6. There is no undo option after deletion.",
    "expected": "Schema deletion should use a styled in-app confirmation dialog consistent with the rest of the application, handle errors with a user-facing toast notification, and provide an undo option (similar to ScheduledReportsPanel's undo toast).",
    "actual": "Uses native window.confirm() dialog, silently swallows deletion errors, and provides no undo capability.",
    "impact": "Users may permanently delete important schemas without proper confirmation or the ability to recover, and failed deletions appear to succeed due to missing error handling."
  },
  {
    "bug_id": "R10-B-015",
    "severity": "LOW",
    "category": "Edge Case",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:127",
    "description": "The ReadabilityDashboard returns null (line 127) when the analysis prop is null/undefined, rendering a completely blank page with no user feedback. While the parent ReadabilityPage handles loading and error states, there is a race condition where the view is set to 'results' but currentResult is null and loadError is also null (line 272-278). During this gap, the user sees a spinner, but if the analysis data is empty (not null) or has missing expected properties, the dashboard renders with broken layouts rather than a graceful fallback.",
    "steps": "1. Navigate directly to /app/readability/[some-id] where the analysis has been partially saved with missing data. 2. The ReadabilityDashboard renders but category scores, recommendations, or check results may be undefined. 3. Observe potential rendering issues with empty sections.",
    "expected": "The dashboard should validate the analysis data structure on load and show a clear message if required data fields are missing, rather than rendering broken/empty sections.",
    "actual": "The dashboard renders whatever data is available, potentially showing empty charts, zero-score cards, or blank recommendation lists without any indication that data is incomplete.",
    "impact": "Users viewing analyses with incomplete data see a confusing partially-rendered dashboard that may mislead them about the actual content quality."
  },
  {
    "bug_id": "R10-B-016",
    "severity": "MEDIUM",
    "category": "Feedback Gap",
    "component": "ReadabilityShareView",
    "file_line": "src/components/readability/ReadabilityShareView.jsx:93",
    "description": "The ReadabilityShareView's PDF export button (handleExportPDF at line 93-100) catches errors but only logs them to console. There is no user-facing error notification if the PDF export fails. Unlike other export actions in the app that use toast.error() for failure feedback, the shared view silently fails. Additionally, there is no loading toast during the export process - only the button shows a spinner, but for large reports the export can take several seconds with no other progress indication.",
    "steps": "1. Open a shared readability analysis link. 2. Click 'Download PDF Report'. 3. If the export fails (e.g., browser PDF generation error), observe no error message is shown to the user. 4. The button spinner stops and nothing happens.",
    "expected": "PDF export failures should show a user-facing error notification (toast), and the export process should provide clear feedback during generation such as a loading toast with 'Generating PDF...'.",
    "actual": "Export errors are only logged to console.error. The user sees the button spinner stop but receives no notification of success or failure.",
    "impact": "Users on the shared view (who may not be registered users) have no indication why their PDF download failed and no guidance on how to resolve the issue."
  }
]
