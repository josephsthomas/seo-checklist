[
  {
    "bug_id": "R01-200",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "useFavoritesAndRecents",
    "file_line": "src/hooks/useFavoritesAndRecents.js:66",
    "description": "addToFavorites, removeFromFavorites, and addToRecents use stale closure values of `favorites` and `recents` state. When these callbacks fire in quick succession, they reference outdated snapshots of the arrays, causing earlier mutations to be overwritten.",
    "steps": "1. Open a page using useFavoritesAndRecents hook.\n2. Rapidly click 'Add to Favorites' on two different items in quick succession.\n3. Observe that only the second item appears in favorites.",
    "expected": "Both items should be added to favorites since each operation should see the latest state.",
    "actual": "The second addToFavorites call captures the stale `favorites` array (without the first item), so the first add is lost when saveData is called the second time.",
    "impact": "Users who quickly favorite multiple items will lose some favorites. The same issue affects addToRecents at line 103."
  },
  {
    "bug_id": "R01-201",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "useNotifications",
    "file_line": "src/hooks/useNotifications.js:60",
    "description": "markAllAsRead uses a Firestore writeBatch without checking if the number of unread notifications exceeds the Firestore batch limit of 500 operations. If a user has more than 500 unread notifications, batch.commit() will throw an error.",
    "steps": "1. Accumulate more than 500 unread notifications for a user.\n2. Click 'Mark all as read'.\n3. Observe an error toast.",
    "expected": "All notifications should be marked as read, splitting into multiple batches if necessary.",
    "actual": "Firestore throws 'Maximum 500 writes allowed per batch' error and no notifications are marked as read.",
    "impact": "Power users or users who haven't cleared notifications for a long time will be unable to mark all as read."
  },
  {
    "bug_id": "R01-202",
    "severity": "HIGH",
    "category": "Missing Error Handling",
    "component": "useProjects",
    "file_line": "src/hooks/useProjects.js:90",
    "description": "getProject is an async function that calls getDoc without a try/catch. If the Firestore call fails (network error, permission denied), the unhandled promise rejection will crash the caller without any user feedback.",
    "steps": "1. Call getProject with a projectId while offline or with insufficient permissions.\n2. The function throws an unhandled error.",
    "expected": "The function should catch errors and return null or throw a user-friendly error with a toast notification.",
    "actual": "An unhandled promise rejection propagates to the caller with no toast notification or error handling.",
    "impact": "Any component calling getProject without its own try/catch will experience unhandled errors, potentially crashing the UI."
  },
  {
    "bug_id": "R01-203",
    "severity": "HIGH",
    "category": "Race Condition",
    "component": "useReadabilityAnalysis",
    "file_line": "src/hooks/useReadabilityAnalysis.js:454",
    "description": "In analyzeUrl, the abort signal is read from abortControllerRef.current at line 454 before runAnalysis creates a new AbortController at line 309. If analyzeUrl is called twice rapidly, the second call's fetchUrlViaProxy may use the stale signal from the first call's controller, leading to incorrect cancellation.",
    "steps": "1. Call analyzeUrl with URL A.\n2. Immediately call analyzeUrl with URL B before the proxy fetch for A completes.\n3. Cancel the analysis.\n4. The wrong fetch may be cancelled.",
    "expected": "Each analyzeUrl invocation should create and use its own isolated abort controller before any async work begins.",
    "actual": "abortControllerRef.current is read at line 454 before runAnalysis assigns a new controller at line 309-310, creating a race window.",
    "impact": "Users who rapidly re-analyze different URLs may experience incorrect cancellation or zombie network requests."
  },
  {
    "bug_id": "R01-204",
    "severity": "MEDIUM",
    "category": "Memory Leak",
    "component": "useFileAttachments",
    "file_line": "src/hooks/useFileAttachments.js:114",
    "description": "uploadFile creates a Promise wrapping uploadBytesResumable with state_changed listener callbacks that call setUploading and setUploadProgress. If the component unmounts during upload, these callbacks fire on unmounted state, causing a React memory leak warning. There is no cleanup or mounted check.",
    "steps": "1. Start a file upload via uploadFile.\n2. Navigate away from the page before the upload completes.\n3. Observe React 'Can't perform a React state update on an unmounted component' warning.",
    "expected": "The hook should track mount status with a ref and skip setState calls after unmount, or cancel the upload task on unmount via a useEffect cleanup.",
    "actual": "The upload continues in the background and calls setState on an unmounted component when it completes or errors.",
    "impact": "Users who navigate away during uploads will trigger console warnings and potentially unstable application state."
  },
  {
    "bug_id": "R01-205",
    "severity": "MEDIUM",
    "category": "Race Condition",
    "component": "useReadabilityHistory",
    "file_line": "src/hooks/useReadabilityHistory.js:114",
    "description": "loadHistory references `lastDoc` from closure state (line 114) but when called with resetPagination=false, it uses a potentially stale lastDoc value if multiple loadMore calls are triggered before the first completes. This can result in duplicate entries in the history array.",
    "steps": "1. Open the readability history page.\n2. Scroll to trigger loadMore rapidly.\n3. Observe duplicate analysis entries in the list.",
    "expected": "Each pagination request should use the lastDoc from the most recently completed request.",
    "actual": "Multiple concurrent loadMore calls all use the same stale lastDoc, fetching the same page multiple times and appending duplicates at line 153.",
    "impact": "Users scrolling quickly through history may see duplicate entries and experience inconsistent pagination."
  },
  {
    "bug_id": "R01-206",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "useReadabilitySettings",
    "file_line": "src/hooks/useReadabilitySettings.js:61",
    "description": "updateSettings captures `settings` in its closure (line 61: `const newSettings = { ...settings, ...updates }`). If updateSettings is called twice in rapid succession, the second call will use the stale settings state that doesn't include the first update's changes, overwriting them.",
    "steps": "1. Call updateSettings({ enabledLLMs: ['claude'] }).\n2. Immediately call updateSettings({ defaultExportFormat: 'json' }) before the first call completes.\n3. Observe that enabledLLMs reverts to the default value.",
    "expected": "Each updateSettings call should use the functional updater pattern (setSettings(prev => ...)) to ensure it sees the latest state.",
    "actual": "The second call spreads the stale `settings` object, losing the first call's changes.",
    "impact": "Users who change multiple settings rapidly will lose some changes, leading to inconsistent preferences."
  },
  {
    "bug_id": "R01-207",
    "severity": "HIGH",
    "category": "Race Condition",
    "component": "aiAnalyzer",
    "file_line": "src/lib/readability/aiAnalyzer.js:52",
    "description": "analyzeWithAI creates its own AbortController (line 52) and a timeout (line 53), but when the caller passes options.signal, the local controller's abort is never wired to the external signal. The external signal is used as fallback (line 54: `const signal = options.signal || controller.signal`), but the local timeout still triggers controller.abort() which has no effect when options.signal is used. Conversely, if the caller aborts via options.signal, the timeout is never cleared.",
    "steps": "1. Call analyzeWithAI with an external signal from useReadabilityAnalysis.\n2. The user cancels the analysis via the external signal.\n3. The internal 120s timeout still fires after the abort, calling controller.abort() on a controller whose signal is unused.",
    "expected": "The timeout should be linked to the actual signal being used. If an external signal is provided, the internal controller and timeout should be coordinated with it.",
    "actual": "When options.signal is provided, the internal controller's timeout fires uselessly, and the clearTimeout in finally only clears the internal timeout, not any external abort handling.",
    "impact": "Cancelled analyses leave dangling timeouts. Timeout-based aborts fail to actually cancel the request when an external signal is provided."
  },
  {
    "bug_id": "R01-208",
    "severity": "LOW",
    "category": "Performance Bug",
    "component": "useFormWithUnsavedChanges",
    "file_line": "src/hooks/useUnsavedChanges.js:58",
    "description": "The dirty detection useEffect at line 57-60 uses JSON.stringify to deep-compare `values` and `originalValues` on every render when either changes. For large forms, this is an O(n) operation on every keystroke that could cause UI jank.",
    "steps": "1. Use useFormWithUnsavedChanges with a form containing many fields or large text areas.\n2. Type rapidly in a text field.\n3. Observe potential lag as JSON.stringify runs on every character.",
    "expected": "Dirty detection should use a shallow comparison or a debounced deep comparison to avoid unnecessary serialization on every keystroke.",
    "actual": "JSON.stringify is called on both values and originalValues on every state change, creating unnecessary CPU overhead.",
    "impact": "Forms with large data sets may experience sluggish typing performance."
  },
  {
    "bug_id": "R01-209",
    "severity": "HIGH",
    "category": "Performance Bug",
    "component": "unifiedExportService",
    "file_line": "src/lib/unifiedExportService.js:6",
    "description": "unifiedExportService statically imports jsPDF, jspdf-autotable, ExcelJS, and JSZip at module level (lines 6-9). These are large libraries that will be included in the main bundle even if the user never exports anything. The readability export hook (useReadabilityExport.js) correctly uses dynamic imports for these, but unifiedExportService defeats that optimization.",
    "steps": "1. Build the application.\n2. Inspect the bundle output.\n3. Observe jsPDF, ExcelJS, and JSZip are in the main chunk.",
    "expected": "These heavy libraries should be dynamically imported only when an export operation is triggered, as done in useReadabilityExport.js.",
    "actual": "Static imports force all three libraries into the main bundle, increasing initial load time by potentially hundreds of KB.",
    "impact": "All users pay the cost of loading export libraries on first page load, even if they never use export functionality."
  },
  {
    "bug_id": "R01-210",
    "severity": "LOW",
    "category": "Memory Leak",
    "component": "pdfGenerator",
    "file_line": "src/lib/pdfGenerator.js:301",
    "description": "previewPDF creates a blob URL with URL.createObjectURL, opens it in a new window, then immediately schedules URL.revokeObjectURL after only 100ms (line 304). If the browser hasn't finished loading the PDF in the new tab within 100ms, the URL is revoked and the preview fails. This is a race condition that manifests as a memory leak (if revoke is delayed) or broken preview (if revoke is too early).",
    "steps": "1. Generate a multi-page PDF.\n2. Call previewPDF.\n3. On a slow connection or with a large PDF, the 100ms timeout may revoke the URL before the new tab finishes loading.",
    "expected": "The blob URL should be revoked when the new window closes, not after an arbitrary 100ms timeout.",
    "actual": "The 100ms timeout is a race: either too early (breaking the preview) or the URL is never properly revoked if the window stays open.",
    "impact": "Users may see a blank PDF preview tab, or blob URLs accumulate in memory for long-lived browser sessions."
  },
  {
    "bug_id": "R01-211",
    "severity": "MEDIUM",
    "category": "Race Condition",
    "component": "auditStorageService",
    "file_line": "src/lib/audit/auditStorageService.js:297",
    "description": "getSharedAudit increments viewCount using a read-then-write pattern (reads viewCount at line 269, writes viewCount+1 at line 298). If two users access the shared link simultaneously, both read the same viewCount value and write the same incremented value, losing one view count.",
    "steps": "1. Share an audit link.\n2. Two users open the link simultaneously.\n3. Both read viewCount=5, both write viewCount=6 instead of 7.",
    "expected": "viewCount should be incremented atomically using Firestore's increment() function to handle concurrent access.",
    "actual": "Non-atomic read-then-write pattern causes lost updates under concurrent access.",
    "impact": "Shared audit view counts will be inaccurate under concurrent access, showing fewer views than actual."
  },
  {
    "bug_id": "R01-212",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "useSchemaLibrary",
    "file_line": "src/hooks/useSchemaLibrary.js:122",
    "description": "incrementUsage calls updateDoc without a try/catch and references the stale `schemas` array from closure state. If the schema was deleted between renders, the find at line 123 may succeed with stale data but updateDoc will fail with a Firestore 'not found' error that goes unhandled.",
    "steps": "1. Open the schema library.\n2. In another tab, delete a schema.\n3. In the first tab, use the deleted schema (triggering incrementUsage).\n4. An unhandled promise rejection occurs.",
    "expected": "incrementUsage should wrap the updateDoc call in a try/catch and handle the case where the schema no longer exists.",
    "actual": "The unhandled promise rejection propagates silently, and the stale schemas closure may reference a deleted document.",
    "impact": "Concurrent usage across tabs can lead to unhandled errors. The stale schemas closure at line 123 also means the usageCount increment may be based on outdated data."
  },
  {
    "bug_id": "R01-213",
    "severity": "LOW",
    "category": "React Anti-Pattern",
    "component": "useReadabilityHistory",
    "file_line": "src/hooks/useReadabilityHistory.js:318",
    "description": "Two useEffect hooks at lines 314 and 321 both suppress the react-hooks/exhaustive-deps ESLint rule with eslint-disable-line comments. The effect at line 314 depends on loadHistory but only lists currentUser, and the effect at line 321 omits loadHistory and currentUser. This means filter/sort changes may use stale buildQuery references.",
    "steps": "1. Log in as a user.\n2. Change the sort field.\n3. In some cases, loadHistory may use a stale buildQuery that doesn't reflect the new sort, returning incorrectly ordered data.",
    "expected": "The dependency arrays should properly include all dependencies, or the logic should be restructured to avoid the need for suppressions.",
    "actual": "ESLint rules are suppressed, hiding potential stale closure bugs when filters or sort change.",
    "impact": "Edge cases where filter/sort changes don't trigger proper reloads, leading to stale data display."
  },
  {
    "bug_id": "R01-214",
    "severity": "MEDIUM",
    "category": "Race Condition",
    "component": "useUserProfile",
    "file_line": "src/hooks/useUserProfile.js:33",
    "description": "useUserProfile defines an async fetchProfile function inside useEffect and calls it without cancellation logic. If targetUserId changes rapidly (e.g., navigating between user profiles), multiple concurrent fetches race and the last to resolve sets state, which may not correspond to the current targetUserId.",
    "steps": "1. Navigate to user profile A.\n2. Immediately navigate to user profile B.\n3. If profile A's fetch resolves after profile B's fetch, profile A's data overwrites profile B's display.",
    "expected": "A cleanup function should cancel or ignore stale fetch results when targetUserId changes.",
    "actual": "All fetches run to completion and the last to resolve wins, regardless of whether its targetUserId is still current.",
    "impact": "Users navigating quickly between profiles may briefly see the wrong user's profile data."
  }
]
