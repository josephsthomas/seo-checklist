[
  {
    "bug_id": "R09-A-001",
    "severity": "CRITICAL",
    "category": "Environment Issue",
    "component": "Firebase Configuration",
    "file_line": "src/lib/firebase.js:6",
    "description": "Firebase is initialized without any validation of required environment variables. The firebaseConfig object reads seven VITE_FIREBASE_* variables from import.meta.env and passes them directly to initializeApp(). If any required variable (apiKey, authDomain, projectId) is undefined, Firebase will initialize with an invalid configuration, producing cryptic runtime errors instead of a clear startup failure. There is no guard, no early throw, and no .env presence check.",
    "steps": "1. Remove or leave blank the VITE_FIREBASE_API_KEY variable from .env\n2. Run 'npm run build && npm run preview' or 'npm run dev'\n3. Open the application in a browser\n4. Attempt to log in or access any authenticated page",
    "expected": "Application should fail fast with a clear, descriptive error message indicating which Firebase environment variables are missing, and prevent rendering of components that depend on Firebase.",
    "actual": "Firebase initializes with undefined values, leading to obscure 'auth/invalid-api-key' or 'FirebaseError' messages at runtime that are difficult to diagnose. The app may partially render before crashing.",
    "impact": "Deployment to any new environment (staging, production, CI) without all Firebase env vars will produce a broken application with no actionable error message, causing extended downtime and debugging time."
  },
  {
    "bug_id": "R09-A-002",
    "severity": "CRITICAL",
    "category": "Deploy Risk",
    "component": "AI Services - API Key Exposure",
    "file_line": "src/lib/schema-generator/schemaGeneratorService.js:38",
    "description": "Three of the five AI service modules (schemaGeneratorService.js, imageAltService.js, metaGeneratorService.js) allow direct API key usage in production without blocking it. Unlike suggestionService.js which throws an error when import.meta.env.PROD is true and only an apiKey is configured, these three services silently fall through to direct browser API calls. The VITE_CLAUDE_API_KEY would be embedded in the production JavaScript bundle, visible in browser DevTools Network tab.",
    "steps": "1. Set VITE_CLAUDE_API_KEY in .env and leave VITE_AI_PROXY_URL unset\n2. Run 'npm run build'\n3. Open the production build in a browser\n4. Navigate to Schema Generator, Image Alt Generator, or Meta Generator\n5. Open DevTools > Network and trigger an AI feature\n6. Inspect the outgoing request headers",
    "expected": "All AI services should block direct API key usage in production builds, consistent with the behavior of suggestionService.js which throws an explicit error in production mode.",
    "actual": "schemaGeneratorService.js (line 38), imageAltService.js (line 38), and metaGeneratorService.js (line 38) allow direct API key usage regardless of build mode, exposing the API key in the client-side JavaScript bundle.",
    "impact": "If VITE_CLAUDE_API_KEY is set in a production deployment, the Anthropic API key is exposed to all users, enabling unauthorized API usage, potential billing abuse, and a security breach requiring key rotation."
  },
  {
    "bug_id": "R09-A-003",
    "severity": "HIGH",
    "category": "Monitoring Gap",
    "component": "ErrorBoundary",
    "file_line": "src/components/shared/ErrorBoundary.jsx:21",
    "description": "The ErrorBoundary component only logs errors in development mode (import.meta.env.DEV) and has no integration with any external error monitoring service (Sentry, LogRocket, Datadog, etc.). In production builds, componentDidCatch silently swallows the error and errorInfo. There is also no global window error or unhandledrejection handler anywhere in the application (confirmed via codebase search). Production errors are completely invisible to the engineering team.",
    "steps": "1. Deploy the application to production (npm run build && serve)\n2. Trigger a rendering error in any component (e.g., pass invalid props to a chart component)\n3. Check if any error telemetry is sent to an external service\n4. Check server logs for any error reports",
    "expected": "Production errors should be reported to an error monitoring service (e.g., Sentry) with full context including error message, component stack, user info, and URL. Global unhandled errors and promise rejections should also be captured.",
    "actual": "Errors are only console.error'd in development. In production, errors are caught by ErrorBoundary but not reported anywhere. No global error handlers exist. Production errors are completely invisible.",
    "impact": "The team has zero visibility into production errors. Users may encounter broken pages repeatedly without anyone knowing, leading to user churn, data loss, and inability to prioritize fixes. Critical issues like chunk loading failures or Firebase outages would go undetected."
  },
  {
    "bug_id": "R09-A-004",
    "severity": "HIGH",
    "category": "Bundle Size",
    "component": "Component-Level jsPDF Imports",
    "file_line": "src/components/meta-generator/CompetitorAnalysisPanel.jsx:20",
    "description": "Multiple UI components directly import jsPDF and jspdf-autotable at the top level instead of using dynamic imports. These are large libraries (~300KB combined) that get statically bundled into each component's chunk. Affected files: CompetitorAnalysisPanel.jsx (line 20), VPATReportGenerator.jsx (line 18), BatchAuditPanel.jsx (line 21). While the vite.config.js has manualChunks for 'vendor-jspdf', these static imports force the chunk to load whenever any of these components mount, even if the user never triggers a PDF export.",
    "steps": "1. Run 'npm run build' and inspect the output chunk sizes\n2. Navigate to the Meta Generator page and open Competitor Analysis\n3. Observe network requests in DevTools\n4. Note that the jsPDF vendor chunk loads immediately on component mount, not when 'Export PDF' is clicked",
    "expected": "jsPDF and jspdf-autotable should be dynamically imported (e.g., const jsPDF = (await import('jspdf')).default) only when the user actually clicks an export button, reducing initial component load by ~300KB.",
    "actual": "jsPDF is statically imported at the module top level in at least 4 component files, causing the ~300KB vendor-jspdf chunk to be downloaded eagerly whenever those components mount.",
    "impact": "Users on slow connections experience unnecessary delays loading components that include PDF export functionality. The jsPDF chunk downloads even when users never intend to export, wasting bandwidth and increasing Time to Interactive."
  },
  {
    "bug_id": "R09-A-005",
    "severity": "HIGH",
    "category": "Code Splitting",
    "component": "ReadabilityDashboard Lazy Imports",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:10",
    "description": "ReadabilityDashboard uses React.lazy() directly for ReadabilityCategoryChart and ReadabilityLLMPreview (lines 10 and 12), bypassing the application's lazyWithRetry utility. The lazyWithRetry wrapper (src/utils/lazyWithRetry.js) provides retry logic with 3 attempts and 1-second delays for chunk loading failures. By using raw lazy(), these sub-components lack retry resilience and will crash into the ErrorBoundary on the first transient network failure instead of retrying.",
    "steps": "1. Open the Readability tool and run an analysis to reach the dashboard\n2. Simulate a slow/unreliable network (DevTools > Network > Offline for 2 seconds, then back)\n3. Switch to the 'Score Details' tab which loads ReadabilityCategoryChart\n4. Observe the chunk load failure",
    "expected": "ReadabilityCategoryChart and ReadabilityLLMPreview should use lazyWithRetry() consistent with all other lazy-loaded components in App.jsx, providing automatic retry on transient network failures.",
    "actual": "These components use bare React.lazy() and will fail immediately on any chunk loading error, showing the error boundary fallback UI with no automatic retry.",
    "impact": "Users on unreliable networks (mobile, public WiFi) will see error screens when viewing readability analysis results, despite the rest of the application being resilient to transient chunk load failures."
  },
  {
    "bug_id": "R09-A-006",
    "severity": "HIGH",
    "category": "Error Logging",
    "component": "lazyWithRetry Production Logging",
    "file_line": "src/utils/lazyWithRetry.js:37",
    "description": "The lazyWithRetry utility only logs chunk loading failures in development (import.meta.env.DEV check on line 37). In production, when a module fails to load after 3 retries, the error is silently re-thrown with a generic message. The original error details (network status, URL, error type) are lost. Combined with the lack of production error monitoring (R09-A-003), failed lazy loads in production are completely invisible to the team.",
    "steps": "1. Deploy to production\n2. Deploy a new version that changes chunk hashes\n3. A user with cached HTML but stale chunk references visits the site\n4. lazyWithRetry fails 3 times on the old chunk URL\n5. Check if any error details are available anywhere",
    "expected": "Chunk loading failures in production should be logged to an error reporting service with the original error, module name, retry count, and the failed chunk URL, allowing the team to monitor deployment-related issues.",
    "actual": "In production, the original error is discarded and replaced with a generic 'Failed to load [module]. Please check your connection and try again.' message. No telemetry is sent.",
    "impact": "After deployments, users with stale caches may encounter persistent chunk loading failures. Without production logging, the team cannot measure the frequency of these failures or determine if a deployment caused widespread issues."
  },
  {
    "bug_id": "R09-A-007",
    "severity": "HIGH",
    "category": "Deploy Risk",
    "component": "Accessibility AI Suggestion Service",
    "file_line": "src/lib/accessibility/aiSuggestionService.js:26",
    "description": "The accessibility AI suggestion service has inconsistent production behavior compared to the main suggestionService.js. When VITE_CLAUDE_API_KEY is set and VITE_AI_PROXY_URL is not set, the accessibility service only emits a console.warn (line 27) in production but still proceeds with direct API access, while the main suggestionService.js throws a hard error to block production API key exposure. This creates an inconsistency where one service blocks and another merely warns.",
    "steps": "1. Set VITE_CLAUDE_API_KEY and leave VITE_AI_PROXY_URL unset\n2. Build for production: npm run build\n3. Open the app and navigate to Accessibility Analyzer\n4. Run an audit and click 'Get AI Fix Suggestions'\n5. Check DevTools Console and Network tab",
    "expected": "All AI services should have consistent behavior in production: either block direct API key usage (throw error) or use a proxy. The accessibility service should throw an error in production like suggestionService.js does.",
    "actual": "aiSuggestionService.js logs a console.warn but proceeds with direct API calls in production, exposing the API key in the browser. This is inconsistent with suggestionService.js which throws a blocking error.",
    "impact": "Security inconsistency across AI services means that even if the team believes they have blocked direct API access in production, the accessibility module still exposes it, creating a false sense of security."
  },
  {
    "bug_id": "R09-A-008",
    "severity": "MEDIUM",
    "category": "Build Issue",
    "component": "Vite Build Configuration",
    "file_line": "vite.config.js:25",
    "description": "The Vite build configuration raises the chunkSizeWarningLimit to 600KB (line 25), which is 3x the default 200KB limit. The comment says 'Increase warning limit since we have lazy loading,' but this effectively suppresses warnings about oversized chunks. While manualChunks are configured for vendor libraries, application code chunks that grow beyond 200KB will not trigger any warning during builds, hiding bundle size regressions.",
    "steps": "1. Add a large new dependency to a lazy-loaded component\n2. Run 'npm run build'\n3. Observe that no chunk size warnings appear even if a chunk exceeds 400KB\n4. Compare with default Vite behavior (200KB warning)",
    "expected": "The chunkSizeWarningLimit should remain at or near the default 200KB, or a build analysis step (e.g., rollup-plugin-visualizer) should be configured to detect bundle size regressions. Vendor chunks that are intentionally large should be handled differently.",
    "actual": "The 600KB limit silently allows application chunks to grow to 3x the recommended size without any CI/build warning, making it easy to introduce bundle size regressions undetected.",
    "impact": "Bundle size regressions can accumulate silently over time, degrading page load performance and Core Web Vitals scores, particularly for users on mobile or slow connections."
  },
  {
    "bug_id": "R09-A-009",
    "severity": "MEDIUM",
    "category": "Caching Gap",
    "component": "Analysis Cache - localStorage",
    "file_line": "src/lib/readability/utils/analysisCache.js:44",
    "description": "The readability analysis caching system stores large analysis results in localStorage (line 107), which has a typical 5-10MB limit shared across the entire domain. Each cached analysis includes full check results, recommendations, LLM extractions, and AI assessments. With a MAX_CACHE_ENTRIES of 20 and no per-entry size limit, the cache can quickly exhaust localStorage quota, which is also used by storageHelpers.js for checklist data, time entries, filter presets, and project metadata. The pruneCache function only limits count, not total byte size.",
    "steps": "1. Run readability analyses on 10-15 different content-heavy URLs\n2. Each analysis caches category scores, check results, recommendations, LLM extractions, and AI assessments\n3. Open DevTools > Application > Local Storage and observe total usage\n4. Try to use other localStorage-dependent features (filter presets, time tracking)",
    "expected": "The caching layer should enforce a total byte budget (e.g., 2MB) rather than just an entry count. It should also gracefully handle quota exceeded errors without corrupting other localStorage data.",
    "actual": "The cache enforces only a count limit of 20 entries with no size constraints. Large analyses can push total localStorage usage near the 5MB limit, causing QuotaExceededError for other features. The catch block on line 109 silently ignores quota errors.",
    "impact": "Users who analyze many pages will lose checklist data, filter presets, and time tracking entries when localStorage fills up. The silent error handling means users won't know their data was not saved."
  },
  {
    "bug_id": "R09-A-010",
    "severity": "MEDIUM",
    "category": "Error Logging",
    "component": "Console.log in Production Code",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:448",
    "description": "A console.log statement exists in production component code at ReadabilityDashboard.jsx line 448: 'console.log('Custom weights applied:', weights)'. This is a debugging artifact that was not cleaned up. More broadly, the codebase has over 100 console.error/console.warn calls across hooks and services that output to the browser console in production. While console.error calls serve some purpose during development, they provide no value in production and can leak internal implementation details to users who open DevTools.",
    "steps": "1. Open the Readability tool in a production build\n2. Run an analysis and view the dashboard\n3. Click 'Adjust Weights' and change any weight slider\n4. Open DevTools > Console\n5. Observe the 'Custom weights applied:' log with full weight data",
    "expected": "No console.log statements should exist in production component code. console.error calls should be replaced with or supplemented by a structured logging service that can be disabled in production or routed to a monitoring service.",
    "actual": "A console.log debugging artifact exists in ReadabilityDashboard.jsx. Additionally, 100+ console.error calls across the codebase produce noisy, unstructured output in production browsers with no centralized collection.",
    "impact": "Console.log leaks internal state data to any user viewing DevTools. The volume of console.error output in production makes it difficult for developers to distinguish real issues from expected error handling. No production visibility is gained from these logs."
  },
  {
    "bug_id": "R09-A-011",
    "severity": "MEDIUM",
    "category": "Bundle Size",
    "component": "Eagerly Loaded Public Pages",
    "file_line": "src/App.jsx:25",
    "description": "Seven public marketing pages (LandingPage, AboutPage, FeaturesPage, FeatureDetailPage, HelpCenterPage, GettingStartedPage, NotFoundPage) are eagerly imported in App.jsx (lines 25-31). These are loaded in the initial bundle for all users, including authenticated users who are redirected to /app and never see these pages. The comment says 'eager load for fast marketing site,' but authenticated users pay the cost of downloading this code without ever using it. Additionally, components like KeyboardShortcuts, OnboardingWalkthrough, FeedbackWidget, CookieConsent, and CommandPalette are also eagerly loaded (lines 48-52).",
    "steps": "1. Log into the application\n2. Open DevTools > Network and observe initial JavaScript bundle sizes\n3. Note that public page code (LandingPage, AboutPage, FeaturesPage, etc.) is included in the main chunk\n4. Navigate only within /app routes and never visit any public page",
    "expected": "Public marketing pages should be lazy loaded since authenticated users never visit them. The initial bundle for authenticated users should only include auth components, navigation, and the HomePage. At minimum, non-critical components like KeyboardShortcuts, OnboardingWalkthrough, and CookieConsent should be lazy loaded.",
    "actual": "Public pages and several utility components are statically imported, increasing the initial bundle size for all users regardless of their route. Authenticated users download marketing page code they will never use.",
    "impact": "Increased initial bundle size leads to slower Time to Interactive, especially on mobile devices. Authenticated users (the primary audience) download unnecessary code for marketing pages, adding potentially 50-100KB+ of unused JavaScript to their initial load."
  },
  {
    "bug_id": "R09-A-012",
    "severity": "MEDIUM",
    "category": "Dependency Risk",
    "component": "Package Dependencies",
    "file_line": "package.json:19",
    "description": "The package.json uses caret (^) version ranges for all 18 production dependencies. While this is common, several dependencies are pinned to major versions that may have breaking changes in minor releases. Notable concerns: firebase ^12.7.0 (Firebase SDK is large and frequently updated with potential breaking changes), pdfjs-dist ^5.4.530 (uncommon version pattern suggesting a newer release train), and jspdf ^4.0.0 (major version 4 may have API changes from v3). There is no package-lock.json audit step in the build scripts, and no 'npm audit' or security scanning in the CI pipeline (no CI configuration files found).",
    "steps": "1. Delete node_modules and package-lock.json\n2. Run 'npm install'\n3. Verify that the installed versions may differ from the original lockfile\n4. Run 'npm audit' to check for known vulnerabilities\n5. Look for CI/CD configuration (none found in repository root)",
    "expected": "The project should have a lockfile integrity check in CI, an 'npm audit' step in the build/test pipeline, and ideally Dependabot or Renovate configured for automated dependency updates with security alerts.",
    "actual": "No CI/CD configuration was found. There is no automated dependency security scanning. Caret ranges mean different installations may resolve to different minor versions. No 'npm audit' step exists in package.json scripts.",
    "impact": "Without automated dependency auditing, known vulnerabilities in transitive dependencies may go undetected. Different team members or deployment environments may install different dependency versions, leading to 'works on my machine' issues."
  },
  {
    "bug_id": "R09-A-013",
    "severity": "MEDIUM",
    "category": "Deploy Risk",
    "component": "Build Scripts - No CI/CD Configuration",
    "file_line": "package.json:7",
    "description": "The package.json contains only basic scripts (dev, build, preview, lint, test). There are no CI/CD configuration files in the repository (no .github/workflows, no .gitlab-ci.yml, no Dockerfile, no vercel.json, no firebase.json for hosting). The build process has no automated quality gates: no lint step in build, no test step before deploy, no bundle size budget enforcement, no lighthouse CI, and no environment variable validation.",
    "steps": "1. Search for CI/CD configuration files in the repository root\n2. Review package.json scripts for pre-build or post-build hooks\n3. Check for deployment configuration files\n4. Verify that 'npm run build' does not run lint or tests",
    "expected": "A production application should have CI/CD configuration that: runs lint, runs tests, builds the application, validates environment variables, checks bundle sizes against budgets, and deploys to the appropriate environment. A pre-build script should verify required env vars.",
    "actual": "No CI/CD pipeline configuration exists. The 'build' script is just 'vite build' with no pre-build validation. There is no automated deployment process, no environment variable validation at build time, and no quality gates.",
    "impact": "Without CI/CD, deployments are manual and error-prone. Broken code can be deployed without running tests. Missing environment variables will not be caught until runtime. There is no automated rollback capability."
  },
  {
    "bug_id": "R09-A-014",
    "severity": "MEDIUM",
    "category": "Caching Gap",
    "component": "Vite Build - No Content Hash in Config",
    "file_line": "vite.config.js:11",
    "description": "The Vite build configuration does not explicitly configure output file naming with content hashes for assets beyond the default. While Vite does add hashes to JS chunks by default, there is no explicit configuration for CSS, font, or image asset naming patterns. More critically, there is no configuration for service worker, cache headers, or asset manifest generation. The application has no service worker for offline caching or cache-first strategies, meaning repeat visits always require full network requests for HTML and uncached assets.",
    "steps": "1. Run 'npm run build' and inspect dist/assets directory\n2. Check for a service worker or workbox configuration\n3. Deploy and check HTTP cache headers for static assets\n4. Revisit the site on a slow connection and note no offline support",
    "expected": "Production builds should include: explicit asset naming with content hashes, a service worker for cache-first strategies on static assets, proper cache-control header configuration guidance, and an asset manifest for cache invalidation.",
    "actual": "No service worker exists. No PWA configuration. No explicit cache-control header guidance. Static assets rely solely on whatever headers the hosting provider sets by default.",
    "impact": "Without a service worker, repeat visits are slower than necessary. Users on unreliable connections have no offline fallback. The absence of explicit caching strategy means the application's performance depends entirely on hosting provider defaults."
  },
  {
    "bug_id": "R09-A-015",
    "severity": "LOW",
    "category": "Build Issue",
    "component": "Vite Config - Source Maps",
    "file_line": "vite.config.js:5",
    "description": "The Vite configuration does not explicitly set the build.sourcemap option. By default, Vite does not generate source maps for production builds. While this is often desired for security (not exposing source code), it makes debugging production issues nearly impossible since stack traces from the ErrorBoundary or any reported errors will reference minified/mangled variable names and line numbers that don't correspond to the source code.",
    "steps": "1. Run 'npm run build'\n2. Check dist/assets for .map files (none present by default)\n3. Trigger a production error\n4. Observe that the error stack trace references minified code with unhelpful variable names",
    "expected": "Source maps should be generated during production builds and either uploaded to an error monitoring service (Sentry source map upload) or served with restricted access. The build.sourcemap option should be explicitly set to 'hidden' to generate maps without referencing them in the output files.",
    "actual": "No source maps are generated for production. Combined with the lack of error monitoring (R09-A-003), production error debugging requires reproducing issues locally.",
    "impact": "Production error investigation is significantly slower. Engineers must manually try to reproduce issues locally since production stack traces are unreadable. This increases mean time to resolution for production incidents."
  },
  {
    "bug_id": "R09-A-016",
    "severity": "LOW",
    "category": "Code Splitting",
    "component": "Vendor Chunk Configuration",
    "file_line": "vite.config.js:20",
    "description": "The manualChunks configuration in vite.config.js groups 'htmlparser2', 'franc', and 'jszip' together as 'vendor-readability' (line 20). However, jszip is also used by the audit module (src/lib/audit/zipProcessor.js) for processing ZIP uploads, not just readability. Grouping jszip with readability-specific libraries means the audit tool unnecessarily downloads htmlparser2 and franc when it only needs jszip. Additionally, libraries like 'date-fns', 'chart.js', 'react-chartjs-2', 'mammoth', and 'pdfjs-dist' are not included in manualChunks, which may lead to suboptimal chunk distribution.",
    "steps": "1. Run 'npm run build' and examine chunk composition\n2. Navigate to the Audit tool and upload a ZIP file\n3. Observe that the vendor-readability chunk (containing htmlparser2 + franc + jszip) is loaded\n4. Note that htmlparser2 and franc are not needed for audit ZIP processing",
    "expected": "jszip should be in its own vendor chunk since it's shared across multiple tools. Other large libraries (date-fns, mammoth, pdfjs-dist) should also be in manualChunks to prevent duplication across lazy-loaded routes.",
    "actual": "jszip is bundled with readability-only libraries. Other large dependencies like chart.js, mammoth, and pdfjs-dist have no explicit chunk configuration and may be duplicated across multiple route chunks.",
    "impact": "Suboptimal chunk splitting causes users to download unnecessary code. The audit tool downloads ~200KB of unused readability libraries (htmlparser2, franc) when it only needs jszip (~90KB). Users of multiple tools may also download duplicate copies of un-chunked shared libraries."
  },
  {
    "bug_id": "R09-A-017",
    "severity": "HIGH",
    "category": "Deploy Risk",
    "component": "Meta Generator - PDF Worker CDN",
    "file_line": "src/lib/meta-generator/metaGeneratorService.js:123",
    "description": "The PDF extraction function loads the pdf.js web worker from an external CDN (cdnjs.cloudflare.com) at runtime using a protocol-relative URL. This creates multiple deployment risks: (1) the CDN could be unavailable or blocked by corporate firewalls, (2) strict Content Security Policy headers will block external script loading, (3) the protocol-relative URL '//' can cause issues in certain contexts, and (4) the version is dynamically interpolated from the installed package version which may not match available CDN builds.",
    "steps": "1. Upload a PDF file to the Meta Data Generator tool.\n2. Block access to cdnjs.cloudflare.com via browser DevTools network blocking or configure a strict CSP.\n3. Attempt to process the PDF.\n4. Observe the failure with no user-facing error message explaining the cause.",
    "expected": "The pdf.js worker should be bundled locally or loaded from a self-hosted path via Vite's asset handling (e.g., new URL('pdfjs-dist/build/pdf.worker.min.js', import.meta.url)), with a fallback mechanism if the worker fails to load.",
    "actual": "The worker is loaded from `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js` which fails if the CDN is unreachable, CSP blocks external scripts, or the dynamically interpolated version does not match an available CDN asset path.",
    "impact": "PDF processing is completely broken for users behind corporate firewalls, in environments with strict CSP, or during CDN outages. No error message explains why PDF upload fails, leading to user confusion and support tickets."
  },
  {
    "bug_id": "R09-A-018",
    "severity": "MEDIUM",
    "category": "Error Logging",
    "component": "AuthContext - Silent Error Swallowing",
    "file_line": "src/contexts/AuthContext.jsx:187-189",
    "description": "The deleteAccount function silently catches and ignores Firebase Storage file deletion errors (line 187-189: empty catch block with comment 'Silently fail if no files exist or storage error'). Similarly, fetchUserProfile at line 217 silently swallows Firestore read errors. If storage deletion fails due to permission issues or partial failures, the user receives a success toast ('Your account has been permanently deleted') even though their files remain in Firebase Storage, creating orphaned data and potential GDPR/privacy compliance issues.",
    "steps": "1. Create a user account and upload file attachments to projects.\n2. Modify Firebase Storage rules to temporarily deny delete access.\n3. Delete the account via the settings page.\n4. Observe the success toast message.\n5. Check Firebase Storage console - orphaned user files remain.",
    "expected": "Storage deletion failures should be logged to a monitoring service and the user should be informed if some data could not be fully removed. A retry mechanism or background cleanup job should handle failed deletions.",
    "actual": "Storage deletion errors are silently caught with an empty catch block (line 187). The function proceeds to delete the auth user and shows a success toast. Orphaned storage files remain with no record of the failure.",
    "impact": "Potential GDPR/CCPA compliance violation where user data persists after an account deletion request. No monitoring trail of cleanup failures. Orphaned files accumulate in Firebase Storage, increasing storage costs over time."
  },
  {
    "bug_id": "R09-A-019",
    "severity": "MEDIUM",
    "category": "Deploy Risk",
    "component": "Hosting Configuration - SPA Routing",
    "file_line": "index.html:1-14",
    "description": "The application is a single-page application using BrowserRouter (client-side routing with history API), but there is no hosting/server configuration file defining SPA fallback routing. Without a hosting config (firebase.json, netlify.toml, vercel.json, _redirects, etc.), direct navigation to any route other than '/' (e.g., /app/audit, /login, /features/planner) will return a 404 from the hosting server because those paths do not correspond to physical files.",
    "steps": "1. Run 'npm run build'.\n2. Deploy the dist/ folder to a static hosting provider without SPA configuration.\n3. Navigate to the app and click through to /app/audit.\n4. Refresh the browser page.\n5. Observe a 404 error because the server has no /app/audit/index.html file.",
    "expected": "A hosting configuration file should define that all routes (except for actual static asset paths) should serve index.html, enabling client-side routing to work correctly on page refreshes and direct URL navigation.",
    "actual": "No hosting configuration file exists. Client-side routes like /app/audit, /app/readability, /login, /about, etc. will 404 on page refresh or direct navigation unless the hosting provider is manually configured outside the project.",
    "impact": "Users who bookmark deep links, share URLs, or simply refresh the page will encounter 404 errors. Search engine crawlers will also fail to index any route other than the root, negating SEO efforts for the marketing pages."
  }
]
