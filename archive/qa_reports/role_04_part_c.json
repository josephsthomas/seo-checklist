[
  {
    "bug_id": "R04-200",
    "severity": "MEDIUM",
    "category": "Taxonomy Issue",
    "component": "useExportHistory / useProjectLinkedItems",
    "file_line": "src/hooks/useExportHistory.js:20",
    "description": "Inconsistent taxonomy between EXPORT_TYPES and LINKED_ITEM_TYPES for the same conceptual entities. EXPORT_TYPES uses AUDIT/ACCESSIBILITY/IMAGE_ALT/META_DATA/SCHEMA/CHECKLIST while LINKED_ITEM_TYPES uses audit/accessibility/imageAlt/metaData/schema. Naming conventions differ (snake_case IDs vs camelCase), and CHECKLIST exists in exports but not in linked items. This creates a fractured taxonomy across the application.",
    "steps": "1. Open src/hooks/useExportHistory.js and inspect EXPORT_TYPES at line 20\n2. Open src/hooks/useProjectLinkedItems.js and inspect LINKED_ITEM_TYPES at line 19\n3. Compare the keys, IDs, and labels between the two",
    "expected": "A single, shared taxonomy or enum defining item types consistently across export, linking, and navigation contexts, with uniform naming convention (either camelCase or snake_case, not both).",
    "actual": "Two separate, inconsistent type definitions exist: EXPORT_TYPES uses snake_case IDs (image_alt, meta_data) while LINKED_ITEM_TYPES uses camelCase (imageAlt, metaData). CHECKLIST type exists only in EXPORT_TYPES.",
    "impact": "Developers must manually map between type systems. Users may encounter different labels for the same feature depending on context (e.g., 'Accessibility Report' vs 'Accessibility Audit'). Leads to data integrity issues when linking exports to projects."
  },
  {
    "bug_id": "R04-201",
    "severity": "MEDIUM",
    "category": "Labeling Issue",
    "component": "useExportHistory / useProjectLinkedItems",
    "file_line": "src/hooks/useProjectLinkedItems.js:34",
    "description": "The same feature is labeled differently across data hooks: EXPORT_TYPES.ACCESSIBILITY uses label 'Accessibility Report' (useExportHistory.js:30) while ITEM_TYPE_INFO for accessibility uses label 'Accessibility Audit' (useProjectLinkedItems.js:34). Users see inconsistent terminology for the same feature area.",
    "steps": "1. Navigate to the Export History section and note the label 'Accessibility Report'\n2. Navigate to the Project Linked Items section and note the label 'Accessibility Audit'\n3. Observe the inconsistency",
    "expected": "Consistent label terminology for the same feature across all contexts (either always 'Accessibility Report' or always 'Accessibility Audit').",
    "actual": "'Accessibility Report' in export context vs 'Accessibility Audit' in project linking context.",
    "impact": "Users may not recognize these refer to the same feature, increasing cognitive load and reducing wayfinding confidence."
  },
  {
    "bug_id": "R04-202",
    "severity": "HIGH",
    "category": "Cognitive Overload",
    "component": "useReadabilityAnalysis",
    "file_line": "src/hooks/useReadabilityAnalysis.js:25",
    "description": "The analysis state machine exposes 6 granular internal states (idle, fetching, extracting, analyzing, scoring, error) directly to UI consumers. This creates unnecessary cognitive complexity for users viewing progress indicators. The UI must handle each state separately despite 'fetching', 'extracting', 'analyzing', and 'scoring' all being substages of a single 'in progress' concept.",
    "steps": "1. Open src/hooks/useReadabilityAnalysis.js\n2. Observe STATES object at line 25 with 6 states\n3. Note that the hook exposes state directly plus computed isAnalyzing that collapses 4 states into one boolean\n4. Consider that consumers must decide which abstraction to use",
    "expected": "A simpler state model for UI consumers (e.g., idle/analyzing/complete/error) with substage details only in the progress object, following progressive disclosure principles.",
    "actual": "Six granular states are exposed alongside duplicate boolean convenience flags (isIdle, isAnalyzing, isComplete, isError), creating two parallel state representations consumers must choose between.",
    "impact": "UI components consuming this hook face confusion about which state representation to use. New developers must understand both representations, increasing cognitive load and risk of state-handling bugs."
  },
  {
    "bug_id": "R04-203",
    "severity": "MEDIUM",
    "category": "Progressive Disclosure",
    "component": "useReadabilityExport",
    "file_line": "src/hooks/useReadabilityExport.js:86",
    "description": "The exportPDF function accepts 12 option parameters including advanced white-labeling features (brandPrimaryColor, brandAccentColor, customFooterText, hidePoweredBy) at the same level as basic options (reportTitle, clientName). No progressive disclosure separates basic from advanced export options. All options are destructured in a single block at line 100-113.",
    "steps": "1. Open src/hooks/useReadabilityExport.js line 86\n2. Examine the options destructuring at lines 100-113\n3. Count the 12 option fields mixed together without grouping",
    "expected": "Options should be organized into logical tiers: basic options (title, client name, toggle sections) vs. advanced/branding options (colors, footer text, branding). This could use nested objects like options.branding.primaryColor.",
    "actual": "All 12 options are flat at the same level with no grouping, mixing basic report configuration with advanced white-labeling settings.",
    "impact": "Consumers of this API face cognitive overload when configuring exports. The flat structure makes it unclear which options are essential vs. advanced, and discoverability of related branding options is poor."
  },
  {
    "bug_id": "R04-204",
    "severity": "LOW",
    "category": "Content Grouping",
    "component": "useFavoritesAndRecents",
    "file_line": "src/hooks/useFavoritesAndRecents.js:9",
    "description": "ITEM_TYPES defines only 4 types (PROJECT, TOOL, AUDIT, RESOURCE) while the application has many more item types across other hooks (accessibility, image_alt, meta_data, schema, checklist). Favorites and recents cannot represent the full taxonomy of items in the application, resulting in incomplete content grouping.",
    "steps": "1. Open src/hooks/useFavoritesAndRecents.js and inspect ITEM_TYPES at line 9\n2. Compare with EXPORT_TYPES in useExportHistory.js (6 types) and LINKED_ITEM_TYPES in useProjectLinkedItems.js (5 types)\n3. Note that favorites can only categorize items into 4 types while the app has many more content types",
    "expected": "ITEM_TYPES in the favorites system should cover all item types present in the application, or use the same shared taxonomy as exports and project links.",
    "actual": "ITEM_TYPES has only 4 entries (project, tool, audit, resource) while the app has at least 6 distinct export types and 5 linked item types.",
    "impact": "Users cannot favorite or track recent items for specific content types like accessibility audits or schema validations. Items may be incorrectly categorized under the generic 'audit' or 'resource' type."
  },
  {
    "bug_id": "R04-205",
    "severity": "HIGH",
    "category": "IA Problem",
    "component": "useReadabilityHistory",
    "file_line": "src/hooks/useReadabilityHistory.js:21",
    "description": "STORAGE_LIMITS is duplicated identically in both useReadabilityHistory.js (line 21) and useReadabilityAnalysis.js (line 38). This role-based configuration defines storage tiers (admin:500, project_manager:250, etc.) and is a critical IA concern because role-based limits should be defined in a single authoritative source. If one file is updated without the other, users see inconsistent storage information.",
    "steps": "1. Open src/hooks/useReadabilityHistory.js line 21 and note STORAGE_LIMITS\n2. Open src/hooks/useReadabilityAnalysis.js line 38 and note identical STORAGE_LIMITS\n3. Observe both define the same role-based limits independently",
    "expected": "A single authoritative source for STORAGE_LIMITS (e.g., in a shared config or constants file) imported by both hooks.",
    "actual": "STORAGE_LIMITS is copy-pasted in two separate files with no shared source of truth.",
    "impact": "If storage tiers change, one file may be updated while the other is not, causing the analysis page to show different limits than the history page. Users see contradictory information about their storage quota."
  },
  {
    "bug_id": "R04-206",
    "severity": "MEDIUM",
    "category": "Navigation Gap",
    "component": "useReadabilityHistory",
    "file_line": "src/hooks/useReadabilityHistory.js:346",
    "description": "The hook exposes both 'loadHistory: refresh' and 'refresh' as separate return values (lines 367-372), but they both point to the same function. This creates a confusing navigation/action API where consumers don't know which to call. Additionally, the aliasing (loadHistory maps to refresh, not the actual loadHistory function) obscures the real behavior.",
    "steps": "1. Open src/hooks/useReadabilityHistory.js lines 346-373\n2. Note that the returned object maps 'loadHistory' to 'refresh' (line 368)\n3. Note that 'refresh' is also returned separately (line 372)\n4. Both point to the same function, creating redundant action labels",
    "expected": "Clear, non-overlapping action names. Either expose 'refresh' or 'loadHistory' but not both pointing to the same function.",
    "actual": "Both 'loadHistory' and 'refresh' are exposed in the return object, and both map to the same 'refresh' function. The actual 'loadHistory' function (line 103) is hidden behind the alias.",
    "impact": "Consumers calling 'loadHistory' expect to load history from scratch but actually get the refresh behavior. This creates a misleading API contract and makes it harder for developers to understand the hook's navigation capabilities."
  },
  {
    "bug_id": "R04-207",
    "severity": "MEDIUM",
    "category": "Taxonomy Issue",
    "component": "useReportBuilder",
    "file_line": "src/hooks/useReportBuilder.js:23",
    "description": "DATA_SOURCES in useReportBuilder uses a third, distinct categorization taxonomy ('Technical Audit', 'Accessibility', 'Content', 'Project', 'Meta & Schema', 'Images') that does not align with either EXPORT_TYPES categories or the readability checker's 5 category system (Content Structure, Content Clarity, Technical Access, Metadata & Schema, AI-Specific Signals). Three different category systems coexist.",
    "steps": "1. Open src/hooks/useReportBuilder.js and note DATA_SOURCES categories at line 23\n2. Compare with CATEGORY_LABELS in useReadabilityExport.js line 19\n3. Compare with EXPORT_TYPES categories in useExportHistory.js\n4. Note three different category systems for the same application",
    "expected": "A unified category taxonomy that is consistent across report builder data sources, readability categories, and export types.",
    "actual": "Three separate category systems: Report builder uses 'Technical Audit/Accessibility/Content/Project/Meta & Schema/Images'; readability uses 'Content Structure/Content Clarity/Technical Accessibility/Metadata & Schema/AI-Specific Signals'; exports use per-tool types.",
    "impact": "Users encounter different organizational models depending on which part of the application they are in. Mental models formed in one area do not transfer to another, significantly increasing cognitive load."
  },
  {
    "bug_id": "R04-208",
    "severity": "MEDIUM",
    "category": "IA Problem",
    "component": "useNotifications / roles",
    "file_line": "src/hooks/useNotifications.js:86",
    "description": "The createNotification function (useNotifications.js:86) accepts a 'type' parameter with no validation or import from the canonical NOTIFICATION_TYPES defined in src/utils/roles.js:122. The notification types enum exists but is disconnected from the notification hook that should consume it. This is an information architecture problem: the authoritative type definition and its consumer are not linked.",
    "steps": "1. Open src/hooks/useNotifications.js line 86 and note the 'type' parameter\n2. Open src/utils/roles.js line 122 and find NOTIFICATION_TYPES with 7 defined types\n3. Note that useNotifications.js never imports or references NOTIFICATION_TYPES\n4. Callers of createNotification have no validation against the canonical types",
    "expected": "useNotifications.js should import NOTIFICATION_TYPES from roles.js and validate the type parameter against it, or the notification types should be co-located with the notification hook.",
    "actual": "NOTIFICATION_TYPES is defined in roles.js (line 122) but never imported or used by useNotifications.js. The type parameter accepts any arbitrary string.",
    "impact": "The taxonomy and its consumer are architecturally disconnected. Invalid notification types can be created without warning, leading to potential UI rendering failures when the notification type is not recognized."
  },
  {
    "bug_id": "R04-209",
    "severity": "HIGH",
    "category": "Content Grouping",
    "component": "recommendations / TOOLS",
    "file_line": "src/lib/recommendations.js:7",
    "description": "The cross-tool recommendations engine defines its own TOOLS object (line 7) with 6 tools (planner, audit, accessibility, image-alt, meta-generator, schema-generator). This does not reference or import from EXPORT_TYPES, LINKED_ITEM_TYPES, or DATA_SOURCES. It is a fourth independent definition of the application's tool/feature taxonomy, with yet another set of IDs (hyphenated slugs like 'image-alt', 'meta-generator') that differ from all other conventions.",
    "steps": "1. Open src/lib/recommendations.js and examine TOOLS at line 7\n2. Note the tool IDs: 'planner', 'audit', 'accessibility', 'image-alt', 'meta-generator', 'schema-generator'\n3. Compare with EXPORT_TYPES IDs (image_alt, meta_data), LINKED_ITEM_TYPES IDs (imageAlt, metaData)\n4. Note this is a fourth distinct taxonomy for the same application features",
    "expected": "All tool/feature references across the application should share a single canonical taxonomy of tool identifiers, names, icons, and colors.",
    "actual": "Four separate tool/feature type definitions exist across the codebase, each with different naming conventions: EXPORT_TYPES (snake_case), LINKED_ITEM_TYPES (camelCase), DATA_SOURCES (display names), and TOOLS (hyphenated slugs).",
    "impact": "Navigation recommendations may link to tools using IDs that do not match routing, export, or project linking systems. Maintaining tool metadata requires updating four separate locations. The user experience feels fragmented."
  },
  {
    "bug_id": "R04-210",
    "severity": "MEDIUM",
    "category": "Labeling Issue",
    "component": "industryProfiles / pageTypeDetector",
    "file_line": "src/lib/readability/profiles/industryProfiles.js:12",
    "description": "Industry profiles use category key 'technicalAccessibility' (line 12, 14, 34, etc.) while the scorer.js and aggregator.js use 'technicalAccess' as the category key. The weight override keys in industry profiles will not match the actual category score keys, rendering industry-specific weight overrides ineffective.",
    "steps": "1. Open src/lib/readability/profiles/industryProfiles.js and note weightOverrides keys (e.g., 'technicalAccessibility' at line 12)\n2. Open src/lib/readability/scorer.js and note category score keys at line 39 (e.g., 'technicalAccess')\n3. Observe that 'technicalAccessibility' !== 'technicalAccess'",
    "expected": "Weight override keys in industry profiles should exactly match the category score keys used by the scoring engine ('technicalAccess').",
    "actual": "Industry profiles use 'technicalAccessibility' while the scoring engine uses 'technicalAccess'. The mismatch means the weight override for this category is silently ignored.",
    "impact": "Industry-specific scoring profiles do not correctly adjust the Technical Accessibility category weight for any industry (technology, healthcare, ecommerce, media, legal). Users selecting an industry profile will not get the expected scoring behavior."
  },
  {
    "bug_id": "R04-211",
    "severity": "LOW",
    "category": "Content Grouping",
    "component": "whyItMatters",
    "file_line": "src/lib/readability/utils/whyItMatters.js:7",
    "description": "The WHY_IT_MATTERS descriptions for CS-07 through CS-10 do not accurately match the check titles they correspond to. CS-07 maps to paragraph length check but the WHY_IT_MATTERS text for CS-07 discusses 'Internal links'. CS-09 maps to 'Logical reading order' but WHY_IT_MATTERS discusses 'Image alt text'. CS-10 maps to 'No content duplication' but describes 'content hierarchy'. The ID-to-description mapping is misaligned.",
    "steps": "1. Open src/lib/readability/utils/whyItMatters.js and read CS-07 text at line 13\n2. Open src/lib/readability/checks/contentStructure.js and find CS-07 (checkParagraphLength) at line 113\n3. Note CS-07 WHY says 'Internal links' but the check is about 'Paragraph length'\n4. Similarly compare CS-09 (reading order vs image alt text) and CS-10 (duplication vs hierarchy)",
    "expected": "Each WHY_IT_MATTERS entry should describe why the corresponding check matters, matching the check's actual purpose.",
    "actual": "CS-07 WHY_IT_MATTERS says 'Internal links help AI models...' but the check is about paragraph length. CS-09 says 'Image alt text...' but the check is about reading order. CS-10 says 'content hierarchy' but the check is about content duplication.",
    "impact": "Users viewing the 'Why This Matters' explanation for these checks receive misleading information that does not relate to the actual check being performed. This erodes trust in the analysis results."
  },
  {
    "bug_id": "R04-212",
    "severity": "MEDIUM",
    "category": "IA Problem",
    "component": "unifiedExportService / readabilityExport",
    "file_line": "src/lib/unifiedExportService.js:14",
    "description": "Two parallel export systems exist: unifiedExportService.js provides generic exportToExcel/exportToPDF/exportToCSV/exportToZip functions, while useReadabilityExport.js has its own completely independent exportPDF/exportJSON/exportExcel implementations with different APIs and styling. The downloadBlob helper function is also duplicated between unifiedExportService.js:14 and readability/exportHubAdapter.js:54.",
    "steps": "1. Open src/lib/unifiedExportService.js and note its export functions (exportToPDF, exportToExcel, etc.)\n2. Open src/hooks/useReadabilityExport.js and note its independent exportPDF, exportJSON, exportExcel implementations\n3. Open src/lib/readability/exportHubAdapter.js:54 and note the duplicate downloadBlob function\n4. Observe that the two export systems have completely independent code paths",
    "expected": "A single export architecture where tool-specific exports (readability, audit, etc.) build on top of the unified export service, sharing common download helpers, PDF styling, and Excel generation logic.",
    "actual": "Two parallel export systems with no shared code. The unified service and readability export have different PDF styling, different Excel generation approaches, and duplicated download helpers.",
    "impact": "Exports from different tools have inconsistent branding, formatting, and behavior. Bug fixes to one export system do not propagate to the other. Users experience a fragmented export experience across tools."
  },
  {
    "bug_id": "R04-213",
    "severity": "MEDIUM",
    "category": "Progressive Disclosure",
    "component": "scorer / checkResults",
    "file_line": "src/lib/readability/scorer.js:83",
    "description": "The scorer returns categoryScores with nested objects containing score/label/weight (line 83-89), but also returns checkResults as a nested object grouped by category key (line 90-96), AND returns allChecks as a flat array (line 97). Consumers receive the same check data in three different shapes: by-category nested objects, a flat array, and the category scores with metadata. No progressive disclosure helps consumers choose the right representation.",
    "steps": "1. Open src/lib/readability/scorer.js lines 77-101\n2. Note that checkResults is returned grouped by category (line 90-96)\n3. Note that allChecks is returned as a flat array of the same data (line 97)\n4. Note that categoryScores includes label and weight metadata (line 83-89)\n5. Observe that the aggregator then flattens checkResults again to store in Firestore",
    "expected": "Check results should be returned in a single canonical shape, with utility functions or computed properties to derive alternate views (flat list, grouped by category) when needed.",
    "actual": "Three overlapping representations of the same data are returned: categoryScores (scores + metadata), checkResults (grouped by category), and allChecks (flat array). The aggregator at line 133 stores checkResults from scoring, not the grouped version.",
    "impact": "Consumers face cognitive overload choosing between three representations. The aggregator stores scoring.checkResults which is the grouped-by-category object, but the export and recommendation code expects a flat array, creating confusion about which shape to reference."
  }
]