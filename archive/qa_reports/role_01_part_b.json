[
  {
    "bug_id": "R01-100",
    "severity": "HIGH",
    "category": "React Anti-Pattern",
    "component": "ReadabilityCheckItem",
    "file_line": "src/components/readability/ReadabilityCheckItem.jsx:154",
    "description": "Uses dangerouslySetInnerHTML to render jargon-annotated text, creating a potential XSS vector. The annotateJargon function injects raw HTML from check.title/check.name which could contain user-supplied content.",
    "steps": "1. Provide a check object with a title containing malicious HTML like '<img src=x onerror=alert(1)>'\n2. Render ReadabilityCheckItem with this check\n3. Observe the injected HTML is rendered unsanitized via dangerouslySetInnerHTML",
    "expected": "User-supplied content should be escaped or rendered using safe React elements, not raw HTML injection.",
    "actual": "Raw HTML from annotateJargon() is injected via dangerouslySetInnerHTML, allowing potential script injection if check titles contain untrusted content.",
    "impact": "Any user or API response that sets check.title with malicious content could execute arbitrary JavaScript in the browser, affecting all users viewing readability results."
  },
  {
    "bug_id": "R01-101",
    "severity": "HIGH",
    "category": "Hook Misuse",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:57",
    "description": "The useEffect that loads trend data calls historyHook.getTrendData().then() but historyHook is omitted from the dependency array (suppressed with eslint-disable). If historyHook reference changes, the effect uses a stale closure over an old hook instance.",
    "steps": "1. Open ReadabilityDashboard with an analysis\n2. The useEffect fires on mount with initial historyHook\n3. If historyHook re-creates (e.g., parent re-render with new hook reference), the effect does not re-run\n4. Trend data may become stale or reference an unmounted hook",
    "expected": "The useEffect should include historyHook in the dependency array or use a stable ref, and handle the promise rejection.",
    "actual": "historyHook is excluded from dependencies via eslint-disable comment, causing potential stale closures. The .then() chain also has no .catch() for error handling.",
    "impact": "Users may see stale trend data. Unhandled promise rejection could cause console errors in production."
  },
  {
    "bug_id": "R01-102",
    "severity": "MEDIUM",
    "category": "Missing Error Handling",
    "component": "ReadabilityDashboard",
    "file_line": "src/components/readability/ReadabilityDashboard.jsx:57",
    "description": "The getTrendData promise chain lacks a .catch() handler. If the async call fails (e.g., network error), the promise rejection goes unhandled.",
    "steps": "1. Open ReadabilityDashboard while offline or with a failing API\n2. The historyHook.getTrendData() promise rejects\n3. No .catch() is present to handle the error",
    "expected": "A .catch() handler should be present to gracefully handle errors, possibly setting an error state or showing a fallback.",
    "actual": "Unhandled promise rejection occurs, potentially crashing in strict mode environments or showing console errors.",
    "impact": "Users in unreliable network conditions will see unhandled promise errors; no user feedback about the failure."
  },
  {
    "bug_id": "R01-103",
    "severity": "MEDIUM",
    "category": "Performance Bug",
    "component": "ReadabilityCoverageTable",
    "file_line": "src/components/readability/ReadabilityCoverageTable.jsx:58",
    "description": "The sortedData computation on lines 58-68 is not wrapped in useMemo. It performs array spread and sort on every render, even when data, sortCol, and sortDir have not changed.",
    "steps": "1. Render ReadabilityCoverageTable with data\n2. Any parent re-render triggers this component to re-render\n3. Observe that sortedData recomputes (array copy + sort) on every single render",
    "expected": "The sorting computation should be memoized with useMemo([data, sortCol, sortDir]) to prevent unnecessary re-computation on every render.",
    "actual": "sortedData is computed as a plain variable derived from data, sortCol, and sortDir, causing re-computation on every render regardless of whether those values changed.",
    "impact": "Performance degradation with large datasets; unnecessary array sorting on every render cycle."
  },
  {
    "bug_id": "R01-104",
    "severity": "MEDIUM",
    "category": "React Anti-Pattern",
    "component": "ReadabilityInputScreen",
    "file_line": "src/components/readability/ReadabilityInputScreen.jsx:292",
    "description": "Direct localStorage access during render (!localStorage.getItem('readability-onboarded')) causes SSR incompatibility and will throw a ReferenceError in server-side rendering environments where localStorage is undefined.",
    "steps": "1. Attempt to server-side render the ReadabilityInputScreen component\n2. The conditional at line 292 calls localStorage.getItem() during render\n3. ReferenceError is thrown because localStorage is not available on the server",
    "expected": "localStorage access should be guarded with a typeof window check or moved into a useEffect/useState pattern to avoid SSR crashes.",
    "actual": "localStorage is accessed directly during render without any guard, causing crashes in SSR environments.",
    "impact": "Breaks server-side rendering; prevents use of SSR frameworks like Next.js; may cause hydration mismatches in universal rendering."
  },
  {
    "bug_id": "R01-105",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "ReadabilityInputScreen",
    "file_line": "src/components/readability/ReadabilityInputScreen.jsx:308",
    "description": "The dismiss button for the onboarding callout calls setActiveTab(activeTab) as a hack to force re-render after writing to localStorage. This does not actually force a re-render since React will bail out when setting state to the same value.",
    "steps": "1. Open ReadabilityInputScreen for the first time (no 'readability-onboarded' in localStorage)\n2. Click 'Dismiss' on the onboarding callout\n3. localStorage is updated, but setActiveTab(activeTab) sets the same value\n4. React bails out of re-render; the callout remains visible",
    "expected": "The component should use a state variable to track dismissal (e.g., useState) so that calling the setter triggers a proper re-render.",
    "actual": "setActiveTab(activeTab) with the same value does not trigger re-render, so the onboarding callout persists until page navigation.",
    "impact": "Users cannot dismiss the onboarding callout on first interaction; poor UX for first-time users."
  },
  {
    "bug_id": "R01-106",
    "severity": "MEDIUM",
    "category": "Performance Bug",
    "component": "ReadabilityIssuesTable",
    "file_line": "src/components/readability/ReadabilityIssuesTable.jsx:159",
    "description": "The SortHeader component is defined as a function inside the render body of ReadabilityIssuesTable. This means it is recreated on every render, causing React to unmount and remount all SortHeader instances instead of reconciling them.",
    "steps": "1. Render ReadabilityIssuesTable with check results\n2. Interact with any filter or sort control\n3. Observe that SortHeader is redefined as a new function on each render\n4. React treats each render's SortHeader as a new component type, unmounting/remounting all headers",
    "expected": "SortHeader should be defined outside the component body or memoized so React can properly reconcile it across renders.",
    "actual": "SortHeader is redefined inside the render function on every render, causing unnecessary unmount/remount cycles for all table headers.",
    "impact": "Causes unnecessary DOM thrashing on every filter or sort interaction; hurts performance with larger datasets."
  },
  {
    "bug_id": "R01-107",
    "severity": "HIGH",
    "category": "Race Condition",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:83",
    "description": "The useEffect that loads an analysis by ID (lines 80-96) fires an async operation but does not track whether the component is still mounted or whether the analysisId has changed. If a user navigates between analyses rapidly, earlier promises may resolve after later ones, overwriting the correct result with stale data.",
    "steps": "1. Navigate to /app/readability/analysis-1\n2. Quickly navigate to /app/readability/analysis-2 before analysis-1 finishes loading\n3. analysis-1 resolves after analysis-2\n4. setLoadedResult(data) from analysis-1 overwrites the correct analysis-2 result",
    "expected": "The effect should use an AbortController or a stale-request flag (let cancelled = false) to discard results from outdated requests.",
    "actual": "No cancellation mechanism exists; the last-resolving promise wins regardless of which analysisId is current, causing a race condition.",
    "impact": "Users may see the wrong analysis results when navigating between analyses quickly, leading to confusion and incorrect data display."
  },
  {
    "bug_id": "R01-108",
    "severity": "HIGH",
    "category": "Hook Misuse",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:96",
    "description": "The useEffect dependency array omits history.getAnalysisById (suppressed with eslint-disable). If the history hook reference changes, the effect uses a stale function reference that may not work correctly.",
    "steps": "1. The history hook re-initializes due to a context change\n2. The useEffect still uses the old history.getAnalysisById reference\n3. The stale function may reference outdated state or fail silently",
    "expected": "Either include the dependency or use a ref to ensure the latest function is always called.",
    "actual": "The eslint-disable comment suppresses the warning, but the stale function reference remains a latent bug.",
    "impact": "Could cause silent failures when loading existing analyses if the history context re-initializes."
  },
  {
    "bug_id": "R01-109",
    "severity": "HIGH",
    "category": "React Anti-Pattern",
    "component": "ReportBuilderPage",
    "file_line": "src/components/reports/ReportBuilderPage.jsx:362",
    "description": "The HTML export function embeds reportName directly into an HTML template string without escaping. If the user sets a report name containing HTML tags or script injection payloads, those will be rendered verbatim in the exported HTML file.",
    "steps": "1. Set reportName to '<script>alert(document.cookie)</script>'\n2. Click Export as HTML\n3. Open the exported HTML file in a browser\n4. The script executes in the context of the HTML file",
    "expected": "The reportName should be HTML-escaped before being interpolated into the HTML template string.",
    "actual": "reportName is interpolated raw into the HTML template on lines 366 and 377, creating an XSS vulnerability in exported files.",
    "impact": "Users who open exported HTML files could be vulnerable to XSS attacks if report names are crafted maliciously, especially in team environments where reports are shared."
  },
  {
    "bug_id": "R01-110",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "ScheduledReportsPanel",
    "file_line": "src/components/reports/ScheduledReportsPanel.jsx:169",
    "description": "The toggleSchedule function reads from the stale `schedules` state variable to find the schedule and display the toast message. Because setSchedules is called before the toast, the toast reads the old isActive value (before the toggle), causing the message to display the inverted status.",
    "steps": "1. Create a schedule that is active (isActive: true)\n2. Click the Pause button to toggle the schedule\n3. setSchedules updates isActive to false\n4. The const schedule = schedules.find(s => s.id === id) still references the old state\n5. Toast shows 'Schedule activated' instead of 'Schedule paused'",
    "expected": "The toast message should reflect the new state. Either compute the new state before calling setSchedules, or read from the updated value.",
    "actual": "schedule.isActive reads the pre-toggle value, so the toast message is inverted: it says 'activated' when pausing and 'paused' when activating.",
    "impact": "Users receive confusing, incorrect feedback about whether a schedule was paused or activated."
  },
  {
    "bug_id": "R01-111",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "useChecklist",
    "file_line": "src/hooks/useChecklist.js:41",
    "description": "In the toggleItem function, the revert-on-error handler at line 63 uses `completions[itemId]` from the closure captured at call time, not the current state. If multiple toggles happen before the error, the revert value may be incorrect.",
    "steps": "1. Call toggleItem(42) which sets completions[42] = true (optimistic)\n2. Before the Firestore update completes, call toggleItem(42) again which sets completions[42] = false\n3. The first Firestore call fails\n4. The catch handler reverts using !completions[itemId] from the first call's closure, which is !false = true\n5. The state is now true, but the second toggle intended it to be false",
    "expected": "The revert should use a functional setState that captures the actual current state, or store the previous value before the optimistic update.",
    "actual": "The revert uses a stale closure reference to completions[itemId], which may not reflect the latest state after concurrent toggles.",
    "impact": "Checklist items may show incorrect completion status after concurrent toggles and a Firestore error, confusing users about task progress."
  },
  {
    "bug_id": "R01-112",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "useAssignments",
    "file_line": "src/hooks/useAssignments.js:60",
    "description": "The assignTask function performs an optimistic state update (line 61) but does not revert the local state if the Firestore update fails. If the server write fails, the UI shows the assignment was made, but it was not persisted.",
    "steps": "1. Call assignTask with a user assignment\n2. The local state is immediately updated at line 61\n3. The Firestore getDoc or setDoc call fails (e.g., network error)\n4. The catch handler logs the error and shows a toast, but does not revert the local state",
    "expected": "On Firestore error, the optimistic local state update should be reverted to the previous state so the UI reflects reality.",
    "actual": "The local state retains the optimistic update even after Firestore fails, causing the UI to show assignments that do not exist in the database.",
    "impact": "Users see phantom task assignments that disappear on page refresh, causing confusion about who is responsible for tasks."
  },
  {
    "bug_id": "R01-113",
    "severity": "MEDIUM",
    "category": "State Bug",
    "component": "useCustomChecklistItems",
    "file_line": "src/hooks/useCustomChecklistItems.js:109",
    "description": "The toggleComplete callback captures customItems via closure but includes it in its dependency array. The function reads `const item = customItems.find(i => i.id === itemId)` using the stale closure. If the function is called rapidly, it may use an outdated version of customItems.",
    "steps": "1. Toggle a custom item's completion status\n2. Rapidly toggle it again before the first Firestore update resolves\n3. The second call may read an outdated `customItems` from the closure\n4. The completed field is toggled based on stale data",
    "expected": "The function should read from a ref or use the Firestore snapshot directly rather than relying on a stale closure over customItems.",
    "actual": "toggleComplete uses customItems from its closure, which may be stale during rapid successive calls.",
    "impact": "Custom checklist items may have their completion status incorrectly toggled under rapid user interaction."
  },
  {
    "bug_id": "R01-114",
    "severity": "LOW",
    "category": "Performance Bug",
    "component": "ReadabilityWeightConfig",
    "file_line": "src/components/readability/ReadabilityWeightConfig.jsx:35",
    "description": "The handleChange useCallback depends on localWeights, which means a new function is created every time any slider moves. This defeats the purpose of useCallback since the dependency changes on every interaction.",
    "steps": "1. Render ReadabilityWeightConfig\n2. Move any slider to change a weight\n3. localWeights changes, causing handleChange to be recreated\n4. All slider onChange handlers receive a new function reference on every change",
    "expected": "Use a functional setState pattern (setLocalWeights(prev => ({ ...prev, [key]: Number(value) }))) and remove localWeights from the dependency array.",
    "actual": "handleChange is recreated on every slider change because localWeights is in the dependency array, even though it could use a functional updater instead.",
    "impact": "Minor performance issue; unnecessary function recreations and child re-renders during slider interactions."
  },
  {
    "bug_id": "R01-115",
    "severity": "LOW",
    "category": "State Bug",
    "component": "useChecklistTemplates",
    "file_line": "src/hooks/useChecklistTemplates.js:122",
    "description": "The incrementUsage callback captures templates via closure. It finds the template and reads template.usageCount to compute the new count. However, if multiple increments happen before Firestore updates, each call reads the same stale usageCount value, losing increments.",
    "steps": "1. Call incrementUsage('template-1') twice in quick succession\n2. Both calls read the same templates array from the closure\n3. Both compute usageCount + 1 from the same stale value\n4. Only one increment is persisted instead of two",
    "expected": "Use Firestore's increment() operator or FieldValue.increment(1) to atomically increment the counter server-side.",
    "actual": "The increment reads the local stale template.usageCount and writes usageCount + 1, causing lost updates under concurrent calls.",
    "impact": "Usage counts for templates may be undercounted, providing inaccurate analytics about which templates are most popular."
  },
  {
    "bug_id": "R01-116",
    "severity": "MEDIUM",
    "category": "Prop Issue",
    "component": "ReportWidgetRenderer",
    "file_line": "src/components/reports/ReportWidgetRenderer.jsx:169",
    "description": "In the renderArrayChart function, circle elements inside the SVG use the array index as the key (key={i} at line 174). Since chart data can be reordered or filtered, using array index as key can cause incorrect reconciliation and animation glitches.",
    "steps": "1. Render a line/area chart with array data\n2. Change the data source or filter the data\n3. React reconciles using index-based keys\n4. Circle elements may animate from/to wrong positions",
    "expected": "Use a stable unique identifier from the data item (e.g., data item name or date) as the key.",
    "actual": "Array index is used as the key, which causes React to reuse DOM elements incorrectly when data changes.",
    "impact": "Chart animations may glitch and circles may appear to jump to wrong positions when data is updated."
  },
  {
    "bug_id": "R01-117",
    "severity": "MEDIUM",
    "category": "Memory Leak",
    "component": "ReadabilityPage",
    "file_line": "src/components/readability/ReadabilityPage.jsx:58",
    "description": "The useEffect for keyboard shortcuts adds an event listener on every showShortcuts change and removes it on cleanup. However, during the transition window between cleanup and re-registration, if the component unmounts, there is no guarantee the cleanup runs synchronously. More importantly, the effect registers a new listener every time showShortcuts toggles, creating rapid add/remove cycles that may miss events.",
    "steps": "1. Open ReadabilityPage\n2. Rapidly press '?' to toggle shortcuts\n3. Each toggle removes and re-adds the keydown listener\n4. During rapid toggling, events may be dropped",
    "expected": "Register the keyboard listener once and use a ref for showShortcuts to avoid re-registering the listener on every state change.",
    "actual": "The keyboard listener is removed and re-added on every showShortcuts toggle, creating a brief window where keyboard events are unhandled.",
    "impact": "Users may experience intermittent failure when pressing Escape to close shortcuts overlay during rapid interaction."
  }
]
